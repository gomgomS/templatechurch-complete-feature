{% extends "admin/base.html" %}

{% block title %}Web Control{% endblock %}

{% block page_heading %}Web Control{% endblock %}

{% block extra_head %}
<!-- Frontend CSS for preview matching -->
<link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
<link rel="stylesheet" href="{{ url_for('static', filename='src/css/bootstrap.css') }}" />
<link rel="stylesheet" href="{{ url_for('static', filename='src/css/styles.css') }}" />
<!-- Shared Quill Preview Match CSS - Ensures editor preview matches frontend exactly -->
<link rel="stylesheet" href="{{ url_for('static', filename='src/css/quill-preview-match.css') }}" />
<style>
    /* Admin-specific styles (not related to Quill preview matching) */
    .card-body {
        padding: 1.5rem;
    }
    
    .form-group {
        margin-bottom: 1.5rem;
    }
    
    .form-group label {
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #495057;
    }
    
    /* Better spacing for existing items */
    .list-group-item {
        transition: background-color 0.2s ease;
    }
    
    .list-group-item:hover {
        background-color: #f8f9fa;
    }
    
    /* Button improvements */
    .btn-sm {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
    }
    
    /* Card header improvements */
    .card-header {
        background-color: #f8f9fa;
        border-bottom: 2px solid #dee2e6;
    }
    
    /* Form input improvements */
    .form-control {
        border-radius: 0.375rem;
        border: 1px solid #ced4da;
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    }
    
    .form-control:focus {
        border-color: #80bdff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    /* Gap utility for flex items */
    .gap-2 {
        gap: 0.5rem;
    }

    /* ===============================
       Right Sidebar Drawer for Existing Items
       =============================== */
    #existingItemsSection {
        position: fixed;
        top: 80px; /* below topbar */
        right: 0;
        width: 420px;
        max-width: 100%;
        height: calc(100vh - 90px);
        z-index: 1040;
        transform: translateX(100%);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        box-shadow: none;
        pointer-events: none; /* prevent clicks when hidden */
    }

    #existingItemsSection.drawer-open {
        transform: translateX(0);
        box-shadow: -4px 0 16px rgba(0, 0, 0, 0.15);
        pointer-events: auto;
    }

    /* Make card fit content inside drawer */
    #existingItemsSection .card {
        max-height: 100%;
        border-radius: 0;
        border-left: 1px solid #e5e7eb;
        display: flex;
        flex-direction: column;
    }

    #existingItemsSection .card-body {
        max-height: calc(100vh - 200px); /* account for card-header and spacing */
        overflow-y: auto;
        flex: 0 1 auto;
    }

    /* Floating toggle button on right edge */
    .drawer-toggle-btn {
        position: fixed;
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        z-index: 1050;
        border-radius: 30px 0 0 30px;
        box-shadow: -2px 2px 8px rgba(0,0,0,0.2);
        padding: 0.5rem 0.75rem;
    }

    .drawer-toggle-btn i {
        transition: transform 0.3s ease;
    }

    .drawer-open-icon {
        transform: rotate(180deg);
    }

    /* Edit section width adjustment based on drawer state */
    #editSection {
        transition: all 0.3s ease;
    }
    
    /* When drawer is open, edit section width = 100% - drawer width (420px) */
    .drawer-open-adjacent #editSection {
        flex: 0 0 calc(100% - 420px);
        max-width: calc(100% - 420px);
        padding-right: 0 !important;
        margin-right: 0 !important;
    }
    
    /* When drawer is closed, edit section is full width */
    .drawer-closed-adjacent #editSection {
        flex: 0 0 100%;
        max-width: 100%;
    }
    
    /* Remove gap between edit section and drawer */
    .drawer-open-adjacent {
        margin-right: 0;
        padding-right: 0;
    }
    
    /* Remove Bootstrap gutter on right side when drawer is open */
    .drawer-open-adjacent > * {
        padding-right: 0;
    }
    
    /* Remove container padding on right when drawer is open */
    .container-fluid:has(.drawer-open-adjacent),
    .container:has(.drawer-open-adjacent) {
        padding-right: 0;
    }
    
    /* Fallback for browsers without :has() support */
    .drawer-open-adjacent {
        margin-right: 0 !important;
    }
    
    /* Ensure edit section card extends to edge */
    .drawer-open-adjacent #editSection .card {
        margin-right: 0;
        border-radius: 0.375rem 0 0 0.375rem;
    }
    
    /* Ensure drawer aligns perfectly with edit section - no gap */
    #existingItemsSection.drawer-open {
        right: 0;
    }
    
    /* Remove any spacing that might create gap */
    .drawer-open-adjacent #editSection {
        margin-right: 0 !important;
    }
    
    /* File picker button styling in Quill toolbar */
    .ql-file-picker,
    .ql-file-picker-static {
        width: 28px;
        position: relative;
    }
    
    /* Hide default Quill SVG icons for custom buttons */
    .ql-file-picker svg,
    .ql-file-picker-static svg {
        display: none !important;
    }
    
    /* Style Font Awesome icons in custom buttons */
    .ql-file-picker i.fas,
    .ql-file-picker-static i.fas {
        display: inline-block !important;
        font-size: 16px;
        line-height: 1;
        vertical-align: middle;
    }
    
    /* Red color for static file picker icon */
    .ql-file-picker-static i.fas {
        color: #dc3545 !important;
    }
    
    .ql-file-picker-static:hover i.fas {
        color: #c82333 !important; /* Darker red on hover */
    }
    
    /* Ensure buttons are visible and clickable */
    .ql-file-picker button,
    .ql-file-picker-static button {
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
    }
    
    /* File list item styling */
    .file-picker-item {
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    
    .file-picker-item:hover {
        background-color: #f8f9fa;
    }
    
    .file-picker-item.selected {
        background-color: #e7f3ff;
        border-left: 3px solid #007bff;
    }
    
    /* Sortable drag and drop styling */
    .sortable-item {
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    
    .sortable-ghost {
        opacity: 0.4;
        background-color: #e3f2fd;
    }
    
    .sortable-drag {
        opacity: 0.8;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .drag-handle {
        opacity: 0.6;
        transition: opacity 0.2s ease;
    }
    
    .sortable-item:hover .drag-handle {
        opacity: 1;
    }
    
    .sortable-chosen {
        background-color: #f8f9fa;
    }
    
    /* HTML Tag Editor styling */
    .html-editor-preview {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        background: white;
        min-height: 200px;
        max-height: 500px;
        overflow-y: auto;
    }
    
    /* Make images smaller by default in preview */
    .html-editor-preview img {
        max-width: 300px;
        max-height: 300px;
        width: auto;
        height: auto;
        object-fit: contain;
    }
    
    /* Dynamic preview sizes - controlled by data-image-size attribute */
    .html-editor-preview[data-image-size] img {
        max-width: var(--preview-image-size, 300px);
        max-height: var(--preview-image-size, 300px);
    }
    
    .html-editor-preview[data-image-size] [data-editable-tag][data-tag-name="img"] {
        max-width: var(--preview-image-size, 300px);
    }
    
    .html-editor-preview [data-editable-tag] {
        cursor: pointer;
        position: relative;
        transition: all 0.2s ease;
        outline: 1px dashed transparent;
        padding: 2px;
        margin: 1px;
    }
    
    .html-editor-preview [data-editable-tag]:hover {
        outline: 2px dashed #007bff;
        background-color: rgba(0, 123, 255, 0.05);
    }
    
    .html-editor-preview [data-editable-tag].selected {
        outline: 2px solid #28a745;
        background-color: rgba(40, 167, 69, 0.1);
    }
    
    .html-editor-preview [data-editable-tag]:hover::before {
        content: attr(data-tag-name);
        position: absolute;
        top: -20px;
        left: 0;
        background: #007bff;
        color: white;
        padding: 2px 6px;
        font-size: 10px;
        border-radius: 3px;
        z-index: 100;
        white-space: nowrap;
    }
    
    /* Special styling for img tags in HTML editor */
    .html-editor-preview [data-editable-tag][data-tag-name="img"] {
        display: inline-block;
        max-width: 300px;  /* Limit default display size */
        cursor: move;
        position: relative;
        border: 2px solid transparent;
        transition: all 0.2s ease;
    }
    
    .html-editor-preview [data-editable-tag][data-tag-name="img"] img {
        max-width: 100%;
        height: auto;
        display: block;
    }
    
    .html-editor-preview [data-editable-tag][data-tag-name="img"]:hover {
        border-color: #28a745;
    }
    
    .html-editor-preview [data-editable-tag][data-tag-name="img"]:hover::before {
        content: "ðŸ–¼ï¸ Drag to move anywhere | Click corners to resize";
        background: #28a745;
        white-space: nowrap;
        top: -25px;
    }
    
    .html-editor-preview [data-editable-tag][data-tag-name="img"].dragging {
        opacity: 0.5;
        border-color: #007bff;
        border-style: dashed;
    }
    
    /* Droppable zones (all elements except images) */
    .html-editor-preview [data-editable-tag].drop-zone {
        min-height: 20px;
        transition: all 0.2s ease;
        position: relative;
    }
    
    /* Drop position indicators - show where image will be placed */
    .html-editor-preview [data-editable-tag].drop-zone::before,
    .html-editor-preview [data-editable-tag].drop-zone::after {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 3px;
        background: transparent;
        z-index: 999;
        transition: all 0.2s ease;
    }
    
    .html-editor-preview [data-editable-tag].drop-zone::before {
        top: 0;
    }
    
    .html-editor-preview [data-editable-tag].drop-zone::after {
        bottom: 0;
    }
    
    /* Drop at top (prepend) */
    .html-editor-preview [data-editable-tag].drop-zone.drop-position-before::before {
        background: #28a745;
        height: 4px;
        box-shadow: 0 0 8px rgba(40, 167, 69, 0.6);
    }
    
    /* Drop at bottom (append) */
    .html-editor-preview [data-editable-tag].drop-zone.drop-position-after::after {
        background: #28a745;
        height: 4px;
        box-shadow: 0 0 8px rgba(40, 167, 69, 0.6);
    }
    
    /* Drop inside (general highlight) */
    .html-editor-preview [data-editable-tag].drop-zone.drop-position-inside {
        background-color: rgba(40, 167, 69, 0.1) !important;
        border: 2px dashed #28a745 !important;
        box-shadow: inset 0 0 10px rgba(40, 167, 69, 0.2);
    }
    
    /* Old drag-over class - kept for backward compatibility */
    .html-editor-preview [data-editable-tag].drop-zone.drag-over {
        background-color: rgba(40, 167, 69, 0.1) !important;
        border: 2px dashed #28a745 !important;
        padding: 10px;
        box-shadow: inset 0 0 10px rgba(40, 167, 69, 0.2);
    }
    
    /* Position indicator labels */
    .drop-position-indicator {
        position: absolute;
        background: #28a745;
        color: white;
        padding: 3px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .drop-position-indicator.before {
        top: -2px;
        left: 50%;
        transform: translate(-50%, -100%);
    }
    
    .drop-position-indicator.after {
        bottom: -2px;
        left: 50%;
        transform: translate(-50%, 100%);
    }
    
    .drop-position-indicator.inside {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    
    /* Resize handles for images */
    .image-resize-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background: #28a745;
        border: 2px solid white;
        border-radius: 50%;
        display: none;
        z-index: 1000;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .html-editor-preview [data-editable-tag][data-tag-name="img"]:hover .image-resize-handle {
        display: block;
    }
    
    .image-resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
    .image-resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
    .image-resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
    .image-resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }
    
    .tag-editor-panel {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 15px;
        background: #f8f9fa;
        margin-top: 10px;
        display: none;
    }
    
    .tag-editor-panel.active {
        display: block;
    }
    
    .html-code-editor {
        font-family: 'Courier New', monospace;
        font-size: 13px;
    }
    
    /* Custom Range Slider Styling */
    .custom-range {
        width: 100%;
        height: 6px;
        background: linear-gradient(to right, #28a745 0%, #ffc107 50%, #dc3545 100%);
        border-radius: 3px;
        outline: none;
        -webkit-appearance: none;
    }
    
    .custom-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #007bff;
        border: 3px solid white;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
    }
    
    .custom-range::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }
    
    .custom-range::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #007bff;
        border: 3px solid white;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.2s ease;
    }
    
    .custom-range::-moz-range-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    }
    
    .dropdown-menu {
        border: 1px solid rgba(0,0,0,0.15);
        box-shadow: 0 6px 12px rgba(0,0,0,0.175);
    }
    
    /* Image Inserter Modal Styles */
    .border-dashed {
        border-style: dashed !important;
    }
    
    #imageDropZone.drag-over {
        background: #d4f4dd !important;
        border-color: #1e7e34 !important;
        transform: scale(1.02);
        transition: all 0.2s ease;
    }
    
    .database-image-item {
        cursor: pointer;
        transition: all 0.2s ease;
        border: 2px solid transparent;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .database-image-item:hover {
        border-color: #28a745;
        transform: scale(1.05);
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }
    
    .database-image-item img {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 6px;
    }
    
    .database-image-item .image-name {
        font-size: 12px;
        padding: 5px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    @media (max-width: 767.98px) {
        #existingItemsSection {
            width: 100%;
            top: 70px;
            height: calc(100vh - 80px);
        }
        
        /* On mobile, edit section is always full width when drawer is open */
        .drawer-open-adjacent #editSection {
            flex: 0 0 100%;
            max-width: 100%;
        }
    }
    
    /* Mobile: reduce top spacing */
    @media (max-width: 576px) {
        .container-fluid > h1:first-of-type {
            margin-bottom: 1rem !important;
        }
        
        .row.mb-4 {
            margin-bottom: 1.5rem !important;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Flash Messages -->
{% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
        {% for category, message in messages %}
            <div class="alert alert-{{ 'danger' if category == 'error' else 'success' }} alert-dismissible fade show" role="alert">
                {{ message }}
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
        {% endfor %}
    {% endif %}
{% endwith %}

<!-- Site Settings Section -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card shadow">
            <div class="card-header py-3" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                <h6 class="m-0 font-weight-bold text-white">
                    <i class="fas fa-cogs"></i> Site Settings
                </h6>
            </div>
            <div class="card-body">
                <form action="{{ url_for('admin_web_control_save_settings') }}" method="POST" id="siteSettingsForm">
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="nav_position">
                                    <i class="fas fa-compass"></i> Navigation Position
                                </label>
                                <select class="form-control" id="nav_position" name="nav_position">
                                    <option value="right" {% if site_settings and site_settings.nav_position == 'right' %}selected{% endif %}>
                                        Right Sidebar (Default)
                                    </option>
                                    <option value="left" {% if site_settings and site_settings.nav_position == 'left' %}selected{% endif %}>
                                        Left Sidebar
                                    </option>
                                </select>
                                <small class="form-text text-muted">
                                    Choose whether the navigation sidebar appears on the left or right side
                                </small>
                            </div>
                        </div>
                        <div class="col-md-6 d-flex align-items-end">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Save Settings
                            </button>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<div class="row drawer-open-adjacent">
    <div class="col-lg-6" id="editSection">
        <div class="card shadow mb-4">
            <div class="card-header py-3 d-flex justify-content-between align-items-center">
                <h6 class="m-0 font-weight-bold text-primary">
                    <i class="fas fa-edit"></i> Add/Edit Navigation & Content
                </h6>
            </div>
            <div class="card-body">
                <form action="{{ url_for('admin_web_control_save') }}" method="POST" id="mainForm">
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                    <input type="hidden" name="nav_key_old" id="nav_key_old" value=""/>
                    
                    <div class="form-group">
                        <label for="nav_name">Nav Name <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="nav_name" name="nav_name" 
                               placeholder="e.g., about, home, services" required>
                        <small class="form-text text-muted">Unique identifier (lowercase, no spaces)</small>
                    </div>
                    
                    <div class="form-group">
                        <label for="nav_label">Label <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="nav_label" name="nav_label" 
                               placeholder="e.g., About, Home, Services" required>
                    </div>
                    
                    <div class="form-group">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <label class="mb-0"><strong>Content Blocks</strong> <span class="text-danger">*</span></label>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-sm btn-primary" onclick="addContentBlock('content')" title="Add Quill Editor Block">
                                    <i class="fas fa-edit"></i> Add Content
                                </button>
                                <!-- Hidden: Raw HTML injection - use HTML Editor instead
                                <button type="button" class="btn btn-sm btn-info" onclick="addContentBlock('injected_html')" title="Add HTML Injection Block">
                                    <i class="fas fa-code"></i> Add HTML
                                </button>
                                -->
                                <button type="button" class="btn btn-sm btn-warning" onclick="addContentBlock('html_editor')" title="Add HTML Tag Editor Block">
                                    <i class="fas fa-tags"></i> HTML Editor
                                </button>
                                <button type="button" class="btn btn-sm btn-success" onclick="addContentBlock('maps')" title="Add Maps Block">
                                    <i class="fas fa-map-marker-alt"></i> Add Maps
                                </button>
                            </div>
                        </div>
                        <div id="contentBlocksContainer">
                            <!-- Content blocks will be dynamically added here -->
                            <p class="text-muted text-center py-3" id="noBlocksMessage">No content blocks yet. Click buttons above to add blocks.</p>
                        </div>
                        <input type="hidden" name="content_blocks" id="contentBlocksData" value="[]">
                    </div>

                    <div class="form-group mt-4">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="enableBackgroundColor" onchange="toggleBackgroundColorForm()">
                            <label class="form-check-label" for="enableBackgroundColor">
                                <i class="fas fa-palette"></i> <strong>Custom Background Color</strong>
                            </label>
                            <small class="form-text text-muted d-block">Check this to set a custom background color for this section</small>
                        </div>
                    </div>

                    <div class="card mt-3" id="backgroundColorCard" style="display: none;">
                        <div class="card-header">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="fas fa-palette"></i> Background Color Settings
                            </h6>
                        </div>
                        <div class="card-body">
                            <div class="form-group">
                                <label for="section_background_color_text">Background</label>
                                <div class="d-flex align-items-center gap-3 flex-wrap">
                                    <input type="text" class="form-control" id="section_background_color_text" name="section_background_color"
                                           placeholder="e.g., #ffffff, red, linear-gradient(135deg,#f8fafc,#eef2ff), rgb(255,255,255)"
                                           style="flex: 1; min-width: 250px;">
                                    <input type="color" class="form-control form-control-color" id="section_background_color_picker" 
                                           value="#ffffff" style="width: 80px; height: 40px; cursor: pointer;"
                                           title="Quick color picker (for solid colors only)">
                                    <button type="button" class="btn btn-sm btn-secondary" onclick="clearBackgroundColor()">
                                        <i class="fas fa-times"></i> Clear
                                    </button>
                                </div>
                                <small class="form-text text-muted">
                                    Enter any CSS background value: hex colors (#ffffff), named colors (red, blue), gradients (linear-gradient(...)), rgb/rgba, etc.
                                    <br><strong>Examples:</strong> <code>#f0f0f0</code>, <code>red</code>, <code>linear-gradient(135deg,#f8fafc,#eef2ff)</code>, <code>rgb(240,240,240)</code>
                                </small>
                            </div>
                            <div class="form-group">
                                <div id="backgroundColorPreview" style="height: 80px; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; background: #ffffff;">
                                    <span class="text-muted">Preview</span>
                                </div>
                                <small class="form-text text-muted">Preview of the selected background.</small>
                            </div>
                        </div>
                    </div>

                    <div class="d-flex justify-content-between mt-4 pt-3 border-top">
                        <button type="button" class="btn btn-secondary" onclick="clearForm()">
                            <i class="fas fa-times"></i> Clear Form
                        </button>
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-save"></i> Save Changes
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Right sidebar drawer: Existing items (open by default) -->
    <div class="col-lg-5 drawer-open" id="existingItemsSection">
        <div class="card shadow mb-4">
            <div class="card-header py-3 d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <button type="button" class="btn btn-sm btn-link text-primary p-0 mr-2" 
                            id="toggleExistingItems" title="Toggle Existing Items"
                            onclick="toggleExistingItemsSection()">
                        <i class="fas fa-chevron-right" id="toggleExistingItemsIcon"></i>
                    </button>
                    <h6 class="m-0 font-weight-bold text-primary" id="existingItemsTitle">
                        <i class="fas fa-list"></i> Existing Items
                    </h6>
                </div>
                <button type="button" class="btn btn-sm btn-success" id="addNewBtn" onclick="addNewSection()" title="Add New Section">
                    <i class="fas fa-plus"></i> Add New
                </button>
            </div>
            <div id="existingItemsContent">
                <div class="card-body p-0">
                    {% if navigation %}
                        <div class="list-group list-group-flush" id="sortableNavList">
                            {% for nav in navigation %}
                            <div class="list-group-item px-3 py-2 border-bottom sortable-item" data-key="{{ nav.key }}">
                                <div class="d-flex align-items-center">
                                    <div class="drag-handle mr-2" style="cursor: move;">
                                        <i class="fas fa-grip-vertical text-muted"></i>
                                    </div>
                                    <div class="flex-grow-1">
                                        <div class="d-flex w-100 justify-content-between align-items-start mb-2">
                                            <div>
                                                <h6 class="mb-1 font-weight-bold">{{ nav.label }}</h6>
                                                <small class="text-muted">
                                                    <i class="fas fa-tag"></i> {{ nav.key }}
                                                </small>
                                            </div>
                                        </div>
                                        <div class="d-flex gap-2 mt-2">
                                            <button type="button" class="btn btn-sm btn-warning edit-item-btn flex-fill" 
                                                    data-key="{{ nav.key }}"
                                                    data-label="{{ nav.label }}"
                                                    title="Edit">
                                                <i class="fas fa-edit"></i> Edit
                                            </button>
                                            <form action="{{ url_for('admin_web_control_delete_nav', nav_key=nav.key) }}" 
                                                  method="POST" style="display: inline; flex: 1;" 
                                                  class="delete-form"
                                                  data-label="{{ nav.label }}">
                                                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                                                <button type="submit" class="btn btn-sm btn-danger w-100" title="Delete">
                                                    <i class="fas fa-trash"></i> Delete
                                                </button>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {% endfor %}
                        </div>
                    {% else %}
                        <p class="text-muted p-3 mb-0">No items yet. Click "Add New" to create a new section.</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Floating toggle button for right sidebar drawer -->
<button type="button"
        class="btn btn-primary drawer-toggle-btn"
        id="drawerToggleButton"
        title="Toggle Existing Items"
        onclick="toggleExistingItemsSection()">
    <i class="fas fa-list" id="drawerToggleIcon"></i>
</button>

<!-- File Picker Modal for Quill Editor -->
<div class="modal fade" id="filePickerModal" tabindex="-1" role="dialog" aria-labelledby="filePickerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="filePickerModalLabel">
                    <i class="fas fa-folder" id="filePickerModalIcon"></i> <span id="filePickerModalTitle">Select File</span>
                </h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-end mb-3" id="filePickerSourceToggle" style="display: none;">
                    <div class="btn-group btn-group-sm" role="group">
                        <button type="button" class="btn btn-outline-primary active" id="toggleDbFiles" onclick="switchFileSource('db')">
                            <i class="fas fa-database"></i> Database
                        </button>
                        <button type="button" class="btn btn-outline-danger" id="toggleStaticFiles" onclick="switchFileSource('static')">
                            <i class="fas fa-file-code"></i> Static (JSON)
                        </button>
                    </div>
                </div>
                <div id="filePickerLoading" class="text-center py-4">
                    <div class="spinner-border text-primary" role="status">
                        <span class="sr-only">Loading...</span>
                    </div>
                    <p class="mt-2 text-muted">Loading files...</p>
                </div>
                <div id="filePickerList" style="display: none;">
                    <div class="list-group" id="fileListContainer">
                        <!-- Files will be inserted here -->
                    </div>
                </div>
                <div id="filePickerEmpty" style="display: none;" class="text-center py-4">
                    <i class="fas fa-folder-open fa-3x text-muted mb-3"></i>
                    <p class="text-muted">No files available. Upload files in the File List section.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Image Inserter Modal for HTML Tag Editor -->
<div class="modal fade" id="imageInserterModal" tabindex="-1" role="dialog" aria-labelledby="imageInserterModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header bg-success text-white">
                <h5 class="modal-title" id="imageInserterModalLabel">
                    <i class="fas fa-image"></i> Insert Image
                </h5>
                <button type="button" class="close text-white" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="text-center mb-4">
                    <p class="text-muted">Choose an image from uploaded files or enter a URL</p>
                </div>
                
                <!-- Drag and Drop / Browse Files Area -->
                <div class="card mb-3">
                    <div class="card-body">
                        <h6 class="card-title"><i class="fas fa-cloud-upload-alt"></i> Upload from Files</h6>
                        <div id="imageDropZone" class="border border-dashed rounded p-5 text-center" 
                             style="border-width: 2px !important; border-color: #28a745 !important; background: #f8fff9; cursor: pointer;"
                             onclick="document.getElementById('imageFileInput').click()">
                            <i class="fas fa-cloud-upload-alt fa-3x text-success mb-3"></i>
                            <p class="mb-2"><strong>Drop image here</strong> or click to browse</p>
                            <small class="text-muted">Supports: JPG, PNG, GIF, WebP</small>
                            <input type="file" id="imageFileInput" accept="image/*" style="display: none;" onchange="handleImageFileSelect(event)">
                        </div>
                        <div id="imageUploadProgress" style="display: none;" class="mt-3">
                            <div class="progress">
                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-success" role="progressbar" style="width: 0%"></div>
                            </div>
                            <p class="text-center text-muted mt-2 mb-0">Uploading...</p>
                        </div>
                    </div>
                </div>
                
                <!-- Browse Database Images -->
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="card-title mb-0"><i class="fas fa-database"></i> Select from Database</h6>
                            <button type="button" class="btn btn-sm btn-primary" onclick="loadDatabaseImagesForInserter()">
                                <i class="fas fa-sync-alt"></i> Refresh
                            </button>
                        </div>
                        <div id="databaseImagesList" style="max-height: 300px; overflow-y: auto;">
                            <div class="text-center py-4">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="sr-only">Loading...</span>
                                </div>
                                <p class="mt-2 text-muted">Loading images...</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Or Enter URL -->
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title"><i class="fas fa-link"></i> Or Enter Image URL</h6>
                        <div class="input-group">
                            <input type="text" class="form-control" id="imageUrlInput" placeholder="https://example.com/image.jpg">
                            <div class="input-group-append">
                                <button type="button" class="btn btn-success" onclick="insertImageFromUrl()">
                                    <i class="fas fa-check"></i> Insert
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_scripts %}
<!-- Quill Editor -->
<link href="{{ url_for('static', filename='lib/quill/quill.snow.css') }}" rel="stylesheet">
<script src="{{ url_for('static', filename='lib/quill/quill.min.js') }}"></script>
<!-- Quill Image Resize Module -->
<script src="https://unpkg.com/quill-image-resize-module@3.0.0/image-resize.min.js"></script>
<!-- SortableJS for drag and drop -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<script type="application/json" id="content-data">
{{ content_data|tojson|safe }}
</script>

<script type="application/json" id="navigation-data">
{{ navigation|tojson|safe }}
</script>

<script type="application/json" id="plugin-data">
{{ plugin_data|tojson|safe }}
</script>

<script type="application/json" id="injected-html-data">
{{ injected_html_data|tojson|safe }}
</script>

<script type="application/json" id="blocks-data">
{{ blocks_data|tojson|safe }}
</script>

<script>
    let contentData = {};
    let navigationData = [];
    let pluginData = {};
    let injectedHtmlData = {};
    let blocksData = {};

    // Load content data from server
    try {
        const dataScript = document.getElementById('content-data');
        if (dataScript && dataScript.textContent) {
            contentData = JSON.parse(dataScript.textContent);
        }
    } catch (e) {
        console.error('Error loading content data:', e);
        contentData = {};
    }

    // Load navigation data from server
    try {
        const navScript = document.getElementById('navigation-data');
        if (navScript && navScript.textContent) {
            navigationData = JSON.parse(navScript.textContent);
        }
    } catch (e) {
        console.error('Error loading navigation data:', e);
        navigationData = [];
    }

    // Load plugin data from server
    try {
        const pluginScript = document.getElementById('plugin-data');
        if (pluginScript && pluginScript.textContent) {
            pluginData = JSON.parse(pluginScript.textContent);
        }
    } catch (e) {
        console.error('Error loading plugin data:', e);
        pluginData = {};
    }

    // Load injected HTML data from server
    try {
        const injectedHtmlScript = document.getElementById('injected-html-data');
        if (injectedHtmlScript && injectedHtmlScript.textContent) {
            injectedHtmlData = JSON.parse(injectedHtmlScript.textContent);
        }
    } catch (e) {
        console.error('Error loading injected HTML data:', e);
        injectedHtmlData = {};
    }

    // Load blocks data from server
    try {
        const blocksScript = document.getElementById('blocks-data');
        if (blocksScript && blocksScript.textContent) {
            blocksData = JSON.parse(blocksScript.textContent);
        }
    } catch (e) {
        console.error('Error loading blocks data:', e);
        blocksData = {};
    }

    // Content blocks management
    let contentBlocks = [];
    let quillInstances = {}; // Store multiple Quill instances by block ID
    
    function addContentBlock(type) {
        // Save all block content before adding new block
        saveAllBlockContent();
        
        const blockId = 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const block = {
            id: blockId,
            type: type,
            data: type === 'maps' ? { latitude: '', longitude: '' } : (type === 'html_editor' ? '' : '')
        };
        contentBlocks.push(block);
        renderContentBlocks();
        // Focus on the new block
        setTimeout(() => {
            if (type === 'content') {
                const quill = quillInstances[blockId];
                if (quill) quill.focus();
            } else if (type === 'injected_html') {
                const textarea = document.querySelector(`[data-block-id="${blockId}"] textarea`);
                if (textarea) textarea.focus();
            } else if (type === 'html_editor') {
                const textarea = document.querySelector(`[data-block-id="${blockId}"] .html-code-editor`);
                if (textarea) textarea.focus();
            }
        }, 200);
    }
    
    function removeContentBlock(blockId) {
        contentBlocks = contentBlocks.filter(b => b.id !== blockId);
        // Destroy Quill instance if exists
        if (quillInstances[blockId]) {
            delete quillInstances[blockId];
        }
        renderContentBlocks();
    }
    
    // Helper function to save all block content before re-rendering
    function saveAllBlockContent() {
        console.log('[saveAllBlockContent] Starting to save all blocks. Total blocks:', contentBlocks.length);
        contentBlocks.forEach((block, idx) => {
            console.log(`[saveAllBlockContent] Block ${idx}: id=${block.id}, type=${block.type}, data=`, block.data);
            
            if (block.type === 'content') {
                // Save Quill editor content
                if (quillInstances[block.id]) {
                    const quill = quillInstances[block.id];
                    const oldData = block.data;
                    block.data = quill.root.innerHTML;
                    console.log(`[saveAllBlockContent] Saved Quill content for block ${block.id}. Length: ${block.data.length}`);
                } else {
                    console.log(`[saveAllBlockContent] No Quill instance found for block ${block.id}, preserving existing data`);
                }
                // If Quill instance doesn't exist, preserve existing block.data (don't overwrite)
                // block.data remains unchanged
            } else if (block.type === 'injected_html') {
                // Save textarea content
                const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                if (blockDiv) {
                    const textarea = blockDiv.querySelector('textarea');
                    if (textarea) {
                        const oldData = block.data;
                        block.data = textarea.value;
                        console.log(`[saveAllBlockContent] Saved HTML content for block ${block.id}. Length: ${block.data.length}`);
                    } else {
                        console.log(`[saveAllBlockContent] Textarea not found in blockDiv for block ${block.id}`);
                    }
                } else {
                    console.log(`[saveAllBlockContent] BlockDiv not found for block ${block.id}, preserving existing data`);
                }
                // If textarea not found, preserve existing block.data (don't overwrite)
                // block.data remains unchanged
            } else if (block.type === 'maps') {
                // Save maps input values
                const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                if (blockDiv) {
                    const latInput = blockDiv.querySelector('.map-latitude-input');
                    const lngInput = blockDiv.querySelector('.map-longitude-input');
                    if (latInput && lngInput) {
                        const lat = parseFloat(latInput.value);
                        const lng = parseFloat(lngInput.value);
                        const oldData = block.data;
                        block.data = {
                            latitude: isNaN(lat) ? '' : lat,
                            longitude: isNaN(lng) ? '' : lng
                        };
                        console.log(`[saveAllBlockContent] Saved maps data for block ${block.id}:`, block.data);
                    } else {
                        console.log(`[saveAllBlockContent] Map inputs not found for block ${block.id}`);
                        // If inputs not found, preserve existing block.data structure
                        if (!block.data || typeof block.data !== 'object') {
                            block.data = { latitude: '', longitude: '' };
                        }
                    }
                } else {
                    console.log(`[saveAllBlockContent] BlockDiv not found for maps block ${block.id}, preserving existing data`);
                    // If blockDiv not found, preserve existing block.data structure
                    if (!block.data || typeof block.data !== 'object') {
                        block.data = { latitude: '', longitude: '' };
                    }
                }
            } else if (block.type === 'html_editor') {
                // Save HTML editor content (just the HTML string)
                const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                if (blockDiv) {
                    const htmlTextarea = blockDiv.querySelector('.html-code-editor');
                    if (htmlTextarea) {
                        block.data = htmlTextarea.value;
                        console.log(`[saveAllBlockContent] Saved HTML editor content for block ${block.id}`);
                    } else {
                        console.log(`[saveAllBlockContent] HTML textarea not found for block ${block.id}`);
                    }
                } else {
                    console.log(`[saveAllBlockContent] BlockDiv not found for html_editor block ${block.id}, preserving existing data`);
                }
            }
            
            console.log(`[saveAllBlockContent] Block ${idx} after save: id=${block.id}, type=${block.type}, data=`, block.data);
        });
        console.log('[saveAllBlockContent] Finished saving all blocks');
    }
    
    function moveBlockUp(blockId) {
        console.log('[moveBlockUp] ===== START =====');
        console.log('[moveBlockUp] Block ID to move:', blockId);
        console.log('[moveBlockUp] Current blocks before save:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
        
        // Save all block content before moving - this updates block.data for all blocks
        saveAllBlockContent();
        
        console.log('[moveBlockUp] Blocks after save:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
        
        const index = contentBlocks.findIndex(b => b.id === blockId);
        console.log('[moveBlockUp] Found block at index:', index);
        
        if (index > 0 && index < contentBlocks.length) {
            const originalLength = contentBlocks.length;
            console.log('[moveBlockUp] Original array length:', originalLength);
            console.log('[moveBlockUp] Block at index', index, ':', contentBlocks[index]);
            console.log('[moveBlockUp] Block at index', index - 1, ':', contentBlocks[index - 1]);
            
            // Create a new array with blocks in the new order to avoid any reference issues
            const newBlocks = [];
            for (let i = 0; i < contentBlocks.length; i++) {
                if (i === index - 1) {
                    // Insert current block at previous position
                    console.log(`[moveBlockUp] Position ${i}: inserting block from index ${index}`, contentBlocks[index]);
                    newBlocks.push(contentBlocks[index]);
                } else if (i === index) {
                    // Insert previous block at current position
                    console.log(`[moveBlockUp] Position ${i}: inserting block from index ${index - 1}`, contentBlocks[index - 1]);
                    newBlocks.push(contentBlocks[index - 1]);
                } else {
                    // Keep other blocks in their original positions
                    console.log(`[moveBlockUp] Position ${i}: keeping block from index ${i}`, contentBlocks[i]);
                    newBlocks.push(contentBlocks[i]);
                }
            }
            
            console.log('[moveBlockUp] New blocks array length:', newBlocks.length);
            console.log('[moveBlockUp] New blocks:', JSON.parse(JSON.stringify(newBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
            
            // Safety check: ensure we didn't lose any blocks
            if (newBlocks.length === originalLength) {
                // Replace the entire array with the new ordered array
                contentBlocks = newBlocks;
                console.log('[moveBlockUp] Array replaced successfully');
                console.log('[moveBlockUp] Final blocks before render:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
                
                // Re-render with the new order (skip save since we already saved)
                renderContentBlocks(true);
                console.log('[moveBlockUp] ===== END =====');
            } else {
                console.error('[moveBlockUp] Block count mismatch! Original:', originalLength, 'New:', newBlocks.length);
            }
        } else {
            console.log('[moveBlockUp] Invalid index or cannot move up');
        }
    }
    
    function moveBlockDown(blockId) {
        console.log('[moveBlockDown] ===== START =====');
        console.log('[moveBlockDown] Block ID to move:', blockId);
        console.log('[moveBlockDown] Current blocks before save:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
        
        // Save all block content before moving - this updates block.data for all blocks
        saveAllBlockContent();
        
        console.log('[moveBlockDown] Blocks after save:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
        
        const index = contentBlocks.findIndex(b => b.id === blockId);
        console.log('[moveBlockDown] Found block at index:', index);
        
        if (index >= 0 && index < contentBlocks.length - 1) {
            const originalLength = contentBlocks.length;
            console.log('[moveBlockDown] Original array length:', originalLength);
            console.log('[moveBlockDown] Block at index', index, ':', contentBlocks[index]);
            console.log('[moveBlockDown] Block at index', index + 1, ':', contentBlocks[index + 1]);
            
            // Create a new array with blocks in the new order to avoid any reference issues
            const newBlocks = [];
            for (let i = 0; i < contentBlocks.length; i++) {
                if (i === index) {
                    // Insert next block at current position
                    console.log(`[moveBlockDown] Position ${i}: inserting block from index ${index + 1}`, contentBlocks[index + 1]);
                    newBlocks.push(contentBlocks[index + 1]);
                } else if (i === index + 1) {
                    // Insert current block at next position
                    console.log(`[moveBlockDown] Position ${i}: inserting block from index ${index}`, contentBlocks[index]);
                    newBlocks.push(contentBlocks[index]);
                } else {
                    // Keep other blocks in their original positions
                    console.log(`[moveBlockDown] Position ${i}: keeping block from index ${i}`, contentBlocks[i]);
                    newBlocks.push(contentBlocks[i]);
                }
            }
            
            console.log('[moveBlockDown] New blocks array length:', newBlocks.length);
            console.log('[moveBlockDown] New blocks:', JSON.parse(JSON.stringify(newBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
            
            // Safety check: ensure we didn't lose any blocks
            if (newBlocks.length === originalLength) {
                // Replace the entire array with the new ordered array
                contentBlocks = newBlocks;
                console.log('[moveBlockDown] Array replaced successfully');
                console.log('[moveBlockDown] Final blocks before render:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data})))));
                
                // Re-render with the new order (skip save since we already saved)
                renderContentBlocks(true);
                console.log('[moveBlockDown] ===== END =====');
            } else {
                console.error('[moveBlockDown] Block count mismatch! Original:', originalLength, 'New:', newBlocks.length);
            }
        } else {
            console.log('[moveBlockDown] Invalid index or cannot move down');
        }
    }
    
    function renderContentBlocks(skipSave) {
        console.log('[renderContentBlocks] ===== START =====');
        console.log('[renderContentBlocks] skipSave:', skipSave);
        console.log('[renderContentBlocks] Total blocks to render:', contentBlocks.length);
        console.log('[renderContentBlocks] Blocks:', JSON.parse(JSON.stringify(contentBlocks.map(b => ({id: b.id, type: b.type, hasData: !!b.data, dataType: typeof b.data})))));
        
        const container = document.getElementById('contentBlocksContainer');
        const noBlocksMessage = document.getElementById('noBlocksMessage');
        
        if (contentBlocks.length === 0) {
            console.log('[renderContentBlocks] No blocks to render');
            container.innerHTML = '<p class="text-muted text-center py-3" id="noBlocksMessage">No content blocks yet. Click buttons above to add blocks.</p>';
            return;
        }
        
        // Save all block content before destroying DOM elements (unless skipSave is true)
        if (!skipSave) {
            console.log('[renderContentBlocks] Calling saveAllBlockContent()');
            saveAllBlockContent();
        } else {
            console.log('[renderContentBlocks] Skipping saveAllBlockContent()');
        }
        
        // Clear existing Quill instances
        const quillInstanceCount = Object.keys(quillInstances).length;
        console.log('[renderContentBlocks] Clearing', quillInstanceCount, 'Quill instances');
        Object.keys(quillInstances).forEach(blockId => {
            delete quillInstances[blockId];
        });
        
        noBlocksMessage?.remove();
        container.innerHTML = '';
        
        let renderedCount = 0;
        contentBlocks.forEach((block, index) => {
            // Skip invalid blocks
            if (!block || !block.id || !block.type) {
                console.warn('[renderContentBlocks] Skipping invalid block at index', index, block);
                return;
            }
            
            console.log(`[renderContentBlocks] Rendering block ${index}: id=${block.id}, type=${block.type}, data=`, block.data);
            renderedCount++;
            
            const blockDiv = document.createElement('div');
            blockDiv.className = 'card mb-3 content-block-item';
            blockDiv.setAttribute('data-block-id', block.id);
            
            let blockContent = '';
            let lat = '';
            let lng = '';
            const typeLabels = {
                'content': 'Quill Editor',
                'injected_html': 'HTML Injection',
                'html_editor': 'HTML Tag Editor',
                'maps': 'Google Maps'
            };
            const typeIcons = {
                'content': 'fa-edit',
                'injected_html': 'fa-code',
                'html_editor': 'fa-tags',
                'maps': 'fa-map-marker-alt'
            };
            
            if (block.type === 'content') {
                blockContent = `
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas ${typeIcons[block.type]}"></i> <strong>${typeLabels[block.type]}</strong>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockUp('${block.id}')" ${index === 0 ? 'disabled' : ''} title="Move Up">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockDown('${block.id}')" ${index === contentBlocks.length - 1 ? 'disabled' : ''} title="Move Down">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button type="button" class="btn btn-outline-danger" onclick="removeContentBlock('${block.id}')" title="Remove">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="quillEditor_${block.id}"></div>
                    </div>
                `;
            } else if (block.type === 'injected_html') {
                blockContent = `
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas ${typeIcons[block.type]}"></i> <strong>${typeLabels[block.type]}</strong>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockUp('${block.id}')" ${index === 0 ? 'disabled' : ''} title="Move Up">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockDown('${block.id}')" ${index === contentBlocks.length - 1 ? 'disabled' : ''} title="Move Down">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button type="button" class="btn btn-outline-danger" onclick="removeContentBlock('${block.id}')" title="Remove">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <textarea class="form-control injected-html-textarea" rows="8" 
                                  placeholder="Paste or type raw HTML code here..."
                                  onchange="updateBlockData('${block.id}', this.value)"
                                  oninput="updateBlockData('${block.id}', this.value)">${escapeHtml(block.data || '')}</textarea>
                    </div>
                `;
            } else if (block.type === 'maps') {
                // Ensure block.data is an object with latitude and longitude
                if (!block.data || typeof block.data !== 'object') {
                    block.data = { latitude: '', longitude: '' };
                }
                lat = block.data.latitude || '';
                lng = block.data.longitude || '';
                blockContent = `
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas ${typeIcons[block.type]}"></i> <strong>${typeLabels[block.type]}</strong>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockUp('${block.id}')" ${index === 0 ? 'disabled' : ''} title="Move Up">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockDown('${block.id}')" ${index === contentBlocks.length - 1 ? 'disabled' : ''} title="Move Down">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button type="button" class="btn btn-outline-danger" onclick="removeContentBlock('${block.id}')" title="Remove">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="form-group">
                            <label>Latitude</label>
                            <input type="number" step="any" class="form-control map-latitude-input" 
                                   placeholder="e.g., -6.2088" value="${lat}"
                                   onchange="updateMapsBlockData('${block.id}')">
                        </div>
                        <div class="form-group">
                            <label>Longitude</label>
                            <input type="number" step="any" class="form-control map-longitude-input" 
                                   placeholder="e.g., 106.8456" value="${lng}"
                                   onchange="updateMapsBlockData('${block.id}')">
                        </div>
                        <div class="form-group">
                            <div class="map-preview" id="mapPreview_${block.id}" style="height: 300px; border: 1px solid #ddd; border-radius: 4px; display: ${lat && lng ? 'block' : 'none'};"></div>
                        </div>
                    </div>
                `;
            } else if (block.type === 'html_editor') {
                // block.data is just the HTML string
                const htmlCode = block.data || '';
                blockContent = `
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <div>
                            <i class="fas fa-tags"></i> <strong>HTML Tag Editor</strong>
                            <small class="text-muted ml-2">Paste HTML and click tags to edit</small>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockUp('${block.id}')" ${index === 0 ? 'disabled' : ''} title="Move Up">
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button type="button" class="btn btn-outline-secondary" onclick="moveBlockDown('${block.id}')" ${index === contentBlocks.length - 1 ? 'disabled' : ''} title="Move Down">
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button type="button" class="btn btn-outline-danger" onclick="removeContentBlock('${block.id}')" title="Remove">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="form-group">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="mb-0">HTML Code</label>
                                <button type="button" class="btn btn-sm btn-success" onclick="openImageInserter('${block.id}')">
                                    <i class="fas fa-image"></i> Add Image
                                </button>
                            </div>
                            <textarea class="form-control html-code-editor" rows="6" 
                                      placeholder="Paste your HTML template here..."
                                      onchange="updateHtmlEditorPreview('${block.id}')"
                                      id="htmlCodeEditor_${block.id}">${escapeHtml(htmlCode)}</textarea>
                            <small class="form-text text-muted">Paste HTML code above, or click "Add Image" to insert images. Click on elements in the preview below to edit their content.</small>
                        </div>
                        <div class="form-group">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="mb-0">Preview (Click elements to edit)</label>
                                <div class="d-flex align-items-center">
                                    <div class="dropdown mr-2">
                                        <button type="button" class="btn btn-sm btn-outline-secondary dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" id="imageSizeBtn_${block.id}">
                                            <i class="fas fa-expand-arrows-alt"></i> Image Size: <span id="imageSizeValue_${block.id}">300px</span>
                                        </button>
                                        <div class="dropdown-menu dropdown-menu-right p-3" style="min-width: 300px;" onclick="event.stopPropagation()">
                                            <h6 class="dropdown-header px-0">Preview Image Size</h6>
                                            <div class="px-2">
                                                <div class="d-flex justify-content-between align-items-center mb-2">
                                                    <small class="text-muted">100px</small>
                                                    <small class="text-muted">800px</small>
                                                </div>
                                                <input type="range" class="custom-range" min="100" max="800" step="50" value="300" id="imageSizeSlider_${block.id}" 
                                                       oninput="updatePreviewImageSize('${block.id}', this.value)">
                                                <div class="text-center mt-2">
                                                    <span class="badge badge-primary" id="imageSizeDisplay_${block.id}">300px</span>
                                                </div>
                                                <div class="d-flex justify-content-between mt-3">
                                                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="setPreviewImageSize('${block.id}', 200)">200px</button>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="setPreviewImageSize('${block.id}', 300)">300px</button>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="setPreviewImageSize('${block.id}', 500)">500px</button>
                                                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="setPreviewImageSize('${block.id}', 800)">Full</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <button type="button" class="btn btn-sm btn-primary" onclick="updateHtmlEditorPreview('${block.id}')">
                                        <i class="fas fa-sync-alt"></i> Refresh
                                    </button>
                                </div>
                            </div>
                            <div class="html-editor-preview" id="htmlPreview_${block.id}" data-image-size="300">
                                <p class="text-muted text-center py-4">Enter HTML code above to see preview</p>
                            </div>
                        </div>
                        <div class="tag-editor-panel" id="tagEditor_${block.id}">
                            <h6 class="mb-3">
                                <i class="fas fa-edit"></i> Edit Tag: <code id="tagName_${block.id}"></code>
                            </h6>
                            <div class="form-group" id="tagContentGroup_${block.id}">
                                <label>Content</label>
                                <textarea class="form-control" id="tagContent_${block.id}" rows="3"></textarea>
                            </div>
                            <div class="form-group" id="tagImageGroup_${block.id}" style="display: none;">
                                <label>Image Source (URL)</label>
                                <div class="input-group mb-2">
                                    <input type="text" class="form-control" id="tagImageSrc_${block.id}" placeholder="Image URL or path">
                                    <div class="input-group-append">
                                        <button type="button" class="btn btn-primary" onclick="openImagePickerForTag('${block.id}')">
                                            <i class="fas fa-folder-open"></i> Browse
                                        </button>
                                    </div>
                                </div>
                                <div id="tagImagePreview_${block.id}" style="max-width: 100%; max-height: 300px; overflow: hidden; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f8f9fa; text-align: center;">
                                    <img id="tagImagePreviewImg_${block.id}" src="" alt="Preview" style="max-width: 100%; max-height: 280px; display: none;">
                                    <p class="text-muted mb-0" id="tagImagePreviewPlaceholder_${block.id}">No image selected</p>
                                </div>
                            </div>
                            <div class="d-flex justify-content-between gap-2">
                                <button type="button" class="btn btn-sm btn-danger" onclick="deleteTag('${block.id}')" title="Delete this element">
                                    <i class="fas fa-trash"></i> Delete Tag
                                </button>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-sm btn-secondary" onclick="closeTagEditor('${block.id}')">
                                        Cancel
                                    </button>
                                    <button type="button" class="btn btn-sm btn-success" onclick="saveTagContent('${block.id}')">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            blockDiv.innerHTML = blockContent;
            container.appendChild(blockDiv);
            
            // Initialize Quill for content blocks
            if (block.type === 'content') {
                setTimeout(() => {
                    // Make sure we don't already have an instance for this block
                    if (!quillInstances[block.id]) {
                        initQuillForBlock(block.id, block.data || '');
                    }
                }, 100);
            }
            
            // Initialize map preview for maps blocks
            if (block.type === 'maps' && lat && lng) {
                setTimeout(() => {
                    updateMapPreviewForBlock(block.id, lat, lng);
                }, 100);
            }
            
            // Initialize HTML editor preview for html_editor blocks
            if (block.type === 'html_editor') {
                setTimeout(() => {
                    updateHtmlEditorPreview(block.id);
                }, 100);
            }
        });
        
        console.log('[renderContentBlocks] Rendered', renderedCount, 'blocks out of', contentBlocks.length);
        console.log('[renderContentBlocks] ===== END =====');
    }
    
    function initQuillForBlock(blockId, initialContent) {
        const editorDiv = document.getElementById(`quillEditor_${blockId}`);
        if (!editorDiv) {
            console.warn(`Quill editor div not found for block ${blockId}`);
            return;
        }
        
        // If instance already exists, don't create a new one
        if (quillInstances[blockId]) {
            console.warn(`Quill instance already exists for block ${blockId}`);
            return;
        }
        
        // Set icons for file-picker buttons
        const icons = Quill.import('ui/icons');
        icons['file-picker'] = '<i class="fas fa-folder"></i>';
        icons['file-picker-static'] = '<i class="fas fa-folder"></i>';
        
        const modulesConfig = {
            toolbar: {
                container: [
                    [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                    ['bold', 'italic', 'underline', 'strike'],
                    [{ 'color': [] }, { 'background': [] }],
                    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                    [{ 'align': [] }],
                    ['link', 'image'],
                    ['file-picker'],
                    ['file-picker-static'],
                    ['clean']
                ],
                handlers: {
                    'file-picker': function() {
                        showFilePickerModal('db');
                    },
                    'file-picker-static': function() {
                        showFilePickerModal('static');
                    }
                }
            },
            clipboard: {
                matchVisual: false
            }
        };
        
        // Add imageResize if available
        if (typeof ImageResize !== 'undefined') {
            let ImageResizeModule = null;
            if (typeof ImageResize === 'function') {
                ImageResizeModule = ImageResize;
            } else if (ImageResize.default && typeof ImageResize.default === 'function') {
                ImageResizeModule = ImageResize.default;
            }
            
            if (ImageResizeModule && !Quill.imports['modules/imageResize']) {
                try {
                    Quill.register('modules/imageResize', ImageResizeModule, true);
                } catch (e) {
                    console.error('Error registering ImageResize:', e);
                }
            }
            
            if (ImageResizeModule) {
                modulesConfig.imageResize = {
                    parchment: Quill.import('parchment'),
                    modules: ['Resize', 'DisplaySize', 'Toolbar']
                };
            }
        }
        
        const quill = new Quill(`#quillEditor_${blockId}`, {
            theme: 'snow',
            modules: modulesConfig,
            formats: ['bold', 'italic', 'underline', 'strike', 'header', 'list', 'bullet', 'color', 'background', 'align', 'link', 'image', 'width', 'height']
        });
        
        if (initialContent) {
            quill.clipboard.dangerouslyPasteHTML(0, initialContent);
        }
        
        quillInstances[blockId] = quill;
    }
    
    function updateBlockData(blockId, value) {
        const block = contentBlocks.find(b => b.id === blockId);
        if (block) {
            block.data = value;
        }
    }
    
    function updateMapsBlockData(blockId) {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const latInput = blockDiv.querySelector('.map-latitude-input');
        const lngInput = blockDiv.querySelector('.map-longitude-input');
        const lat = parseFloat(latInput.value);
        const lng = parseFloat(lngInput.value);
        
        const block = contentBlocks.find(b => b.id === blockId);
        if (block) {
            block.data = {
                latitude: isNaN(lat) ? '' : lat,
                longitude: isNaN(lng) ? '' : lng
            };
            updateMapPreviewForBlock(blockId, block.data.latitude, block.data.longitude);
        }
    }
    
    function updateMapPreviewForBlock(blockId, lat, lng) {
        const previewDiv = document.getElementById(`mapPreview_${blockId}`);
        if (!previewDiv) return;
        
        if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
            previewDiv.style.display = 'block';
            const embedUrl = `https://maps.google.com/maps?q=${lat},${lng}&hl=en&z=14&output=embed`;
            previewDiv.innerHTML = `<iframe src="${embedUrl}" width="100%" height="100%" style="border:0; border-radius:4px;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>`;
        } else {
            previewDiv.style.display = 'none';
        }
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // HTML Tag Editor Functions
    function updateHtmlEditorPreview(blockId) {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const textarea = blockDiv.querySelector('.html-code-editor');
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        if (!textarea || !preview) return;
        
        const htmlCode = textarea.value.trim();
        
        if (!htmlCode) {
            preview.innerHTML = '<p class="text-muted text-center py-4">Enter HTML code above to see preview</p>';
            return;
        }
        
        // Parse HTML and make elements editable
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlCode;
        
        // Make all elements with text content editable (just add markers, don't modify content)
        makeElementsEditable(tempDiv, blockId);
        
        preview.innerHTML = tempDiv.innerHTML;
        
        // Add click event listeners to editable elements
        preview.querySelectorAll('[data-editable-tag]').forEach(el => {
            el.addEventListener('click', (e) => {
                // Don't trigger click if clicking on resize handle
                if (e.target.classList.contains('image-resize-handle')) {
                    e.stopPropagation();
                    return;
                }
                e.stopPropagation();
                selectTagForEditing(blockId, el);
            });
        });
        
        // Setup drag and drop for images
        setupImageDragAndDrop(blockId, preview);
        
        // Setup resize functionality for images
        setupImageResize(blockId, preview);
    }
    
    // Image picker for HTML Tag Editor
    let currentImageTagBlockId = null;
    
    function openImagePickerForTag(blockId) {
        // Store the current block ID for later use
        currentImageTagBlockId = blockId;
        
        // Open file picker modal in database mode (images)
        showFilePickerModal('db');
        
        // Override the file insertion behavior temporarily
        window.tagEditorImagePickerMode = true;
    }
    
    function insertImageForTag(file) {
        if (!currentImageTagBlockId) return;
        
        const tagImageSrc = document.getElementById(`tagImageSrc_${currentImageTagBlockId}`);
        const tagImagePreviewImg = document.getElementById(`tagImagePreviewImg_${currentImageTagBlockId}`);
        const tagImagePreviewPlaceholder = document.getElementById(`tagImagePreviewPlaceholder_${currentImageTagBlockId}`);
        
        if (tagImageSrc) {
            // Use the file URL
            const imageUrl = file.url || file.location || '';
            tagImageSrc.value = imageUrl;
            
            // Update preview
            if (imageUrl && tagImagePreviewImg && tagImagePreviewPlaceholder) {
                tagImagePreviewImg.src = imageUrl;
                tagImagePreviewImg.style.display = 'block';
                tagImagePreviewPlaceholder.style.display = 'none';
            }
        }
        
        // Reset
        currentImageTagBlockId = null;
        window.tagEditorImagePickerMode = false;
    }
    
    // Image Inserter Modal Functions
    let currentHtmlEditorBlockId = null;
    
    // Drag and Drop for Images in HTML Editor
    let draggedImageElement = null;
    let draggedImagePath = null;
    
    function setupImageDragAndDrop(blockId, preview) {
        const images = preview.querySelectorAll('[data-tag-name="img"]');
        const dropZones = preview.querySelectorAll('.drop-zone');
        
        // Setup drag events for images
        images.forEach(img => {
            img.addEventListener('dragstart', (e) => {
                draggedImageElement = img;
                draggedImagePath = img.getAttribute('data-editable-tag');
                img.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', img.outerHTML);
            });
            
            img.addEventListener('dragend', (e) => {
                img.classList.remove('dragging');
                // Remove all drag-over classes and indicators
                dropZones.forEach(zone => {
                    zone.classList.remove('drag-over', 'drop-position-before', 'drop-position-after', 'drop-position-inside');
                });
                // Remove any position indicators
                preview.querySelectorAll('.drop-position-indicator').forEach(ind => ind.remove());
            });
        });
        
        // Setup drop zones
        dropZones.forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                // Calculate drop position based on mouse Y position
                const rect = zone.getBoundingClientRect();
                const mouseY = e.clientY;
                const relativeY = mouseY - rect.top;
                const height = rect.height;
                
                // Remove all position classes first
                zone.classList.remove('drop-position-before', 'drop-position-after', 'drop-position-inside');
                
                // Remove old indicator
                const oldIndicator = zone.querySelector('.drop-position-indicator');
                if (oldIndicator) oldIndicator.remove();
                
                // Determine position: top 30% = before, bottom 30% = after, middle 40% = inside
                let position = 'inside';
                let indicatorText = 'ðŸ“ Drop inside';
                
                if (relativeY < height * 0.3) {
                    position = 'before';
                    indicatorText = 'â¬†ï¸ Drop at start';
                    zone.classList.add('drop-position-before');
                } else if (relativeY > height * 0.7) {
                    position = 'after';
                    indicatorText = 'â¬‡ï¸ Drop at end';
                    zone.classList.add('drop-position-after');
                } else {
                    position = 'inside';
                    zone.classList.add('drop-position-inside');
                }
                
                // Create position indicator
                const indicator = document.createElement('div');
                indicator.className = `drop-position-indicator ${position}`;
                indicator.textContent = indicatorText;
                zone.appendChild(indicator);
                
                // Store position for drop event
                zone.setAttribute('data-drop-position', position);
            });
            
            zone.addEventListener('dragleave', (e) => {
                // Only remove if leaving the element itself, not a child
                if (e.target === zone) {
                    zone.classList.remove('drag-over', 'drop-position-before', 'drop-position-after', 'drop-position-inside');
                    const indicator = zone.querySelector('.drop-position-indicator');
                    if (indicator) indicator.remove();
                }
            });
            
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                zone.classList.remove('drag-over', 'drop-position-before', 'drop-position-after', 'drop-position-inside');
                const indicator = zone.querySelector('.drop-position-indicator');
                if (indicator) indicator.remove();
                
                if (draggedImageElement && draggedImagePath) {
                    const dropPosition = zone.getAttribute('data-drop-position') || 'inside';
                    // Move the image to the new location in the HTML
                    moveImageToContainer(blockId, draggedImagePath, zone.getAttribute('data-editable-tag'), dropPosition);
                }
                
                draggedImageElement = null;
                draggedImagePath = null;
            });
        });
    }
    
    function moveImageToContainer(blockId, imagePath, containerPath, dropPosition = 'inside') {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const htmlTextarea = blockDiv.querySelector('.html-code-editor');
        if (!htmlTextarea) return;
        
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlTextarea.value;
            
            // Find the image element by path
            const imagePathParts = imagePath.split('-').map(Number);
            let imageElement = tempDiv;
            let imageParent = null;
            let imageIndex = -1;
            
            for (let i = 0; i < imagePathParts.length; i++) {
                const childIndex = imagePathParts[i];
                const children = Array.from(imageElement.children);
                if (i === imagePathParts.length - 1) {
                    imageIndex = childIndex;
                    imageParent = imageElement;
                    imageElement = children[childIndex];
                } else {
                    imageElement = children[childIndex];
                }
            }
            
            if (!imageElement || !imageParent) {
                console.error('Could not find image element');
                return;
            }
            
            // Find the container element by path
            const containerPathParts = containerPath.split('-').map(Number);
            let containerElement = tempDiv;
            
            for (let i = 0; i < containerPathParts.length; i++) {
                const childIndex = containerPathParts[i];
                const children = Array.from(containerElement.children);
                containerElement = children[childIndex];
            }
            
            if (!containerElement) {
                console.error('Could not find container element');
                return;
            }
            
            // Clone the image element (to preserve all attributes)
            const imageClone = imageElement.cloneNode(true);
            
            // Remove resize handles from clone (they'll be re-added on preview refresh)
            imageClone.querySelectorAll('.image-resize-handle').forEach(handle => handle.remove());
            
            // Remove the image from its current location
            imageParent.removeChild(imageElement);
            
            // Insert based on drop position
            if (dropPosition === 'before') {
                // Insert as first child (prepend)
                if (containerElement.firstChild) {
                    containerElement.insertBefore(imageClone, containerElement.firstChild);
                } else {
                    containerElement.appendChild(imageClone);
                }
            } else if (dropPosition === 'after') {
                // Append as last child
                containerElement.appendChild(imageClone);
            } else {
                // Default: append to end (inside)
                containerElement.appendChild(imageClone);
            }
            
            // Update the textarea with new HTML
            htmlTextarea.value = tempDiv.innerHTML;
            
            // Update block data
            const block = contentBlocks.find(b => b.id === blockId);
            if (block) {
                block.data = tempDiv.innerHTML;
            }
            
            // Refresh preview
            updateHtmlEditorPreview(blockId);
            
            const positionText = dropPosition === 'before' ? 'at start' : dropPosition === 'after' ? 'at end' : 'inside';
            showToast(`Image moved ${positionText} successfully!`, 'success');
        } catch (e) {
            console.error('Error moving image:', e);
            showToast('Error moving image', 'error');
        }
    }
    
    // Image Resize Functionality
    let resizingImage = null;
    let resizeStartX = 0;
    let resizeStartY = 0;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;
    let resizePosition = '';
    
    function setupImageResize(blockId, preview) {
        const images = preview.querySelectorAll('[data-tag-name="img"]');
        
        images.forEach(imgWrapper => {
            const handles = imgWrapper.querySelectorAll('.image-resize-handle');
            const actualImg = imgWrapper.querySelector('img') || imgWrapper;
            
            handles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizingImage = actualImg;
                    resizePosition = handle.getAttribute('data-position');
                    resizeStartX = e.clientX;
                    resizeStartY = e.clientY;
                    resizeStartWidth = actualImg.offsetWidth;
                    resizeStartHeight = actualImg.offsetHeight;
                    
                    document.addEventListener('mousemove', handleImageResize);
                    document.addEventListener('mouseup', stopImageResize);
                });
            });
        });
    }
    
    function handleImageResize(e) {
        if (!resizingImage) return;
        
        const deltaX = e.clientX - resizeStartX;
        const deltaY = e.clientY - resizeStartY;
        
        let newWidth = resizeStartWidth;
        let newHeight = resizeStartHeight;
        
        // Calculate new dimensions based on resize handle position
        if (resizePosition.includes('e')) {
            newWidth = resizeStartWidth + deltaX;
        } else if (resizePosition.includes('w')) {
            newWidth = resizeStartWidth - deltaX;
        }
        
        if (resizePosition.includes('s')) {
            newHeight = resizeStartHeight + deltaY;
        } else if (resizePosition.includes('n')) {
            newHeight = resizeStartHeight - deltaY;
        }
        
        // Maintain aspect ratio
        const aspectRatio = resizeStartWidth / resizeStartHeight;
        
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            newHeight = newWidth / aspectRatio;
        } else {
            newWidth = newHeight * aspectRatio;
        }
        
        // Set minimum dimensions
        newWidth = Math.max(50, newWidth);
        newHeight = Math.max(50, newHeight);
        
        // Apply new dimensions
        resizingImage.style.width = newWidth + 'px';
        resizingImage.style.height = newHeight + 'px';
    }
    
    function stopImageResize(e) {
        if (!resizingImage) return;
        
        // Update the HTML code with new dimensions
        const blockId = currentHtmlEditorBlockId || Array.from(document.querySelectorAll('[data-block-id]'))
            .find(el => el.contains(resizingImage))
            ?.getAttribute('data-block-id');
        
        if (blockId) {
            updateImageDimensionsInCode(blockId, resizingImage);
        }
        
        document.removeEventListener('mousemove', handleImageResize);
        document.removeEventListener('mouseup', stopImageResize);
        
        resizingImage = null;
    }
    
    function updateImageDimensionsInCode(blockId, imgElement) {
        const imgWrapper = imgElement.closest('[data-editable-tag]');
        if (!imgWrapper) return;
        
        const path = imgWrapper.getAttribute('data-editable-tag');
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const htmlTextarea = blockDiv.querySelector('.html-code-editor');
        if (!htmlTextarea) return;
        
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlTextarea.value;
            
            // Find element by path
            const pathParts = path.split('-').map(Number);
            let targetElement = tempDiv;
            
            for (let i = 0; i < pathParts.length; i++) {
                const childIndex = pathParts[i];
                const children = Array.from(targetElement.children);
                targetElement = children[childIndex];
            }
            
            if (targetElement && targetElement.tagName.toLowerCase() === 'img') {
                // Update width and height in style
                const newWidth = imgElement.style.width;
                const newHeight = imgElement.style.height;
                
                let currentStyle = targetElement.getAttribute('style') || '';
                
                // Remove old width/height from style
                currentStyle = currentStyle.replace(/width:\s*[^;]+;?/gi, '');
                currentStyle = currentStyle.replace(/height:\s*[^;]+;?/gi, '');
                
                // Add new dimensions
                currentStyle += `width: ${newWidth}; height: ${newHeight};`;
                
                targetElement.setAttribute('style', currentStyle.trim());
                
                // Update textarea
                htmlTextarea.value = tempDiv.innerHTML;
                
                // Update block data
                const block = contentBlocks.find(b => b.id === blockId);
                if (block) {
                    block.data = tempDiv.innerHTML;
                }
                
                showToast('Image resized successfully!', 'success');
            }
        } catch (e) {
            console.error('Error updating image dimensions:', e);
        }
    }
    
    // Change preview image size mode
    function changePreviewImageSize(blockId, size) {
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        if (!preview) return;
        
        // Update data attribute
        preview.setAttribute('data-image-size', size);
        
        // Update button states
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (blockDiv) {
            const buttons = blockDiv.querySelectorAll('.btn-group .btn-outline-secondary');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (size === 'small') {
                buttons[0]?.classList.add('active');
            } else if (size === 'medium') {
                buttons[1]?.classList.add('active');
            } else if (size === 'large') {
                buttons[2]?.classList.add('active');
            }
        }
    }
    
    // Update preview image size with slider (real-time)
    function updatePreviewImageSize(blockId, sizeValue) {
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        const displayBadge = document.getElementById(`imageSizeDisplay_${blockId}`);
        const buttonLabel = document.getElementById(`imageSizeValue_${blockId}`);
        
        if (preview) {
            // Update CSS custom property
            preview.style.setProperty('--preview-image-size', sizeValue + 'px');
            preview.setAttribute('data-image-size', sizeValue);
        }
        
        if (displayBadge) {
            displayBadge.textContent = sizeValue + 'px';
        }
        
        if (buttonLabel) {
            buttonLabel.textContent = sizeValue + 'px';
        }
        
        // *** NEW: If an image is currently selected, update its size in the HTML code ***
        const selectedImage = preview ? preview.querySelector('[data-editable-tag].selected[data-tag-name="img"]') : null;
        if (selectedImage) {
            updateSelectedImageSizeInCode(blockId, selectedImage, sizeValue);
        }
    }
    
    // Helper function to update the selected image's size in the HTML code
    function updateSelectedImageSizeInCode(blockId, imgElement, newSize) {
        const path = imgElement.getAttribute('data-editable-tag');
        if (!path) return;
        
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const htmlTextarea = blockDiv.querySelector('.html-code-editor');
        if (!htmlTextarea) return;
        
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlTextarea.value;
            
            // Find element by path
            const pathParts = path.split('-').map(Number);
            let targetElement = tempDiv;
            
            for (let i = 0; i < pathParts.length; i++) {
                const childIndex = pathParts[i];
                const children = Array.from(targetElement.children);
                targetElement = children[childIndex];
            }
            
            if (targetElement && targetElement.tagName.toLowerCase() === 'img') {
                // Update the image size in style attribute
                let currentStyle = targetElement.getAttribute('style') || '';
                
                // Remove old width/height/max-width from style
                currentStyle = currentStyle.replace(/max-width:\s*[^;]+;?/gi, '');
                currentStyle = currentStyle.replace(/width:\s*[^;]+;?/gi, '');
                
                // Add new max-width
                currentStyle += ` max-width: ${newSize}px; height: auto;`;
                currentStyle = currentStyle.trim().replace(/\s+/g, ' ');
                
                targetElement.setAttribute('style', currentStyle);
                
                // Update textarea with new HTML
                htmlTextarea.value = tempDiv.innerHTML;
                
                // Update block data
                const block = contentBlocks.find(b => b.id === blockId);
                if (block) {
                    block.data = tempDiv.innerHTML;
                }
                
                // Also update the preview element directly for immediate visual feedback
                const previewImg = imgElement.querySelector('img') || imgElement;
                if (previewImg) {
                    previewImg.style.maxWidth = newSize + 'px';
                    previewImg.style.height = 'auto';
                }
                
                console.log(`Image size updated to ${newSize}px in HTML code`);
            }
        } catch (e) {
            console.error('Error updating image size in code:', e);
        }
    }
    
    // Set preview image size to specific value (used by quick buttons)
    function setPreviewImageSize(blockId, sizeValue) {
        const slider = document.getElementById(`imageSizeSlider_${blockId}`);
        
        if (slider) {
            slider.value = sizeValue;
            updatePreviewImageSize(blockId, sizeValue);
        }
    }
    
    function openImageInserter(blockId) {
        currentHtmlEditorBlockId = blockId;
        
        // Show modal
        const modal = document.getElementById('imageInserterModal');
        if (typeof $ !== 'undefined') {
            $(modal).modal('show');
        } else {
            modal.style.display = 'block';
            modal.classList.add('show');
        }
        
        // Clear previous input
        document.getElementById('imageUrlInput').value = '';
        
        // Load database images
        loadDatabaseImagesForInserter();
        
        // Setup drag and drop
        setupImageDropZone();
    }
    
    function setupImageDropZone() {
        const dropZone = document.getElementById('imageDropZone');
        if (!dropZone) return;
        
        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });
        
        // Highlight drop zone when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('drag-over');
            }, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('drag-over');
            }, false);
        });
        
        // Handle dropped files
        dropZone.addEventListener('drop', handleImageDrop, false);
    }
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    function handleImageDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length > 0) {
            handleImageFiles(files);
        }
    }
    
    function handleImageFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
            handleImageFiles(files);
        }
    }
    
    function handleImageFiles(files) {
        const file = files[0];
        
        // Check if it's an image
        if (!file.type.startsWith('image/')) {
            showToast('Please select an image file', 'error');
            return;
        }
        
        // Show upload progress
        const progressDiv = document.getElementById('imageUploadProgress');
        if (progressDiv) {
            progressDiv.style.display = 'block';
            const progressBar = progressDiv.querySelector('.progress-bar');
            if (progressBar) progressBar.style.width = '30%';
        }
        
        // Create FormData
        const formData = new FormData();
        formData.append('file', file);
        
        // Get CSRF token
        const csrfToken = document.querySelector('input[name="csrf_token"]')?.value || csrfTokenValue;
        
        // Upload to server
        fetch('{{ url_for("admin_file_list_upload_api") }}', {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (progressDiv) {
                const progressBar = progressDiv.querySelector('.progress-bar');
                if (progressBar) progressBar.style.width = '100%';
            }
            
            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
                
                if (data.success) {
                    // Insert image into HTML editor
                    const imageUrl = data.file.url || data.file.location || '';
                    insertImageTagIntoHtmlEditor(imageUrl, file.name);
                    
                    // Close modal
                    closeImageInserterModal();
                    
                    showToast('Image uploaded and inserted successfully!', 'success');
                } else {
                    showToast('Upload failed: ' + (data.message || 'Unknown error'), 'error');
                }
            }, 500);
        })
        .catch(error => {
            console.error('Upload error:', error);
            if (progressDiv) progressDiv.style.display = 'none';
            showToast('Upload failed. Please try again.', 'error');
        });
    }
    
    function loadDatabaseImagesForInserter() {
        const container = document.getElementById('databaseImagesList');
        if (!container) return;
        
        // Show loading
        container.innerHTML = `
            <div class="text-center py-4">
                <div class="spinner-border text-primary" role="status">
                    <span class="sr-only">Loading...</span>
                </div>
                <p class="mt-2 text-muted">Loading images...</p>
            </div>
        `;
        
        // Fetch images from API
        fetch('{{ url_for("admin_file_list_api") }}')
            .then(response => response.json())
            .then(files => {
                // Filter only images
                const images = files.filter(file => {
                    const filename = (file.original_filename || file.file || '').toLowerCase();
                    return filename.match(/\.(jpg|jpeg|png|gif|webp|svg)$/);
                });
                
                if (images.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-4">
                            <i class="fas fa-images fa-3x text-muted mb-3"></i>
                            <p class="text-muted">No images found. Upload some images first.</p>
                        </div>
                    `;
                    return;
                }
                
                // Display images in a grid
                container.innerHTML = '<div class="row"></div>';
                const row = container.querySelector('.row');
                
                images.forEach(image => {
                    const imageUrl = image.url || image.location || '';
                    const imageName = image.display_name || image.original_filename || 'Image';
                    
                    const col = document.createElement('div');
                    col.className = 'col-md-4 col-sm-6 mb-3';
                    col.innerHTML = `
                        <div class="database-image-item" onclick="insertImageFromDatabase('${escapeHtml(imageUrl)}', '${escapeHtml(imageName)}')">
                            <img src="${imageUrl}" alt="${escapeHtml(imageName)}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'100\\' height=\\'100\\'%3E%3Crect fill=\\'%23ddd\\' width=\\'100\\' height=\\'100\\'/%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' text-anchor=\\'middle\\' dy=\\'.3em\\' fill=\\'%23999\\'%3ENo Image%3C/text%3E%3C/svg%3E'">
                            <div class="image-name text-muted">${escapeHtml(imageName)}</div>
                        </div>
                    `;
                    row.appendChild(col);
                });
            })
            .catch(error => {
                console.error('Error loading images:', error);
                container.innerHTML = `
                    <div class="text-center py-4">
                        <i class="fas fa-exclamation-triangle fa-3x text-danger mb-3"></i>
                        <p class="text-danger">Error loading images. Please try again.</p>
                    </div>
                `;
            });
    }
    
    function insertImageFromDatabase(imageUrl, imageName) {
        insertImageTagIntoHtmlEditor(imageUrl, imageName);
        closeImageInserterModal();
        showToast('Image inserted successfully!', 'success');
    }
    
    function insertImageFromUrl() {
        const urlInput = document.getElementById('imageUrlInput');
        const imageUrl = urlInput.value.trim();
        
        if (!imageUrl) {
            showToast('Please enter an image URL', 'error');
            urlInput.focus();
            return;
        }
        
        // Extract filename from URL if possible
        const filename = imageUrl.split('/').pop().split('?')[0] || 'image';
        
        insertImageTagIntoHtmlEditor(imageUrl, filename);
        closeImageInserterModal();
        showToast('Image inserted successfully!', 'success');
    }
    
    function insertImageTagIntoHtmlEditor(imageUrl, altText = 'image') {
        if (!currentHtmlEditorBlockId) return;
        
        const textarea = document.getElementById(`htmlCodeEditor_${currentHtmlEditorBlockId}`);
        if (!textarea) return;
        
        // Create img tag with proper attributes
        const imgTag = `<img src="${imageUrl}" alt="${altText}" style="max-width: 100%; height: auto;">`;
        
        // Get current cursor position
        const cursorPos = textarea.selectionStart;
        const textBefore = textarea.value.substring(0, cursorPos);
        const textAfter = textarea.value.substring(cursorPos);
        
        // Insert image tag at cursor position
        textarea.value = textBefore + '\n' + imgTag + '\n' + textAfter;
        
        // Update cursor position after inserted text
        const newCursorPos = cursorPos + imgTag.length + 2;
        textarea.setSelectionRange(newCursorPos, newCursorPos);
        textarea.focus();
        
        // Update the block data
        const block = contentBlocks.find(b => b.id === currentHtmlEditorBlockId);
        if (block) {
            block.data = textarea.value;
        }
        
        // Update preview
        updateHtmlEditorPreview(currentHtmlEditorBlockId);
    }
    
    function closeImageInserterModal() {
        const modal = document.getElementById('imageInserterModal');
        if (typeof $ !== 'undefined') {
            $(modal).modal('hide');
        } else {
            modal.style.display = 'none';
            modal.classList.remove('show');
        }
        
        // Reset file input
        const fileInput = document.getElementById('imageFileInput');
        if (fileInput) fileInput.value = '';
        
        currentHtmlEditorBlockId = null;
    }
    
    function makeElementsEditable(element, blockId, path = []) {
        Array.from(element.children).forEach((child, index) => {
            const currentPath = [...path, index];
            const pathStr = currentPath.join('-');
            const tagName = child.tagName.toLowerCase();
            
            // Add data attributes for identification
            child.setAttribute('data-editable-tag', pathStr);
            child.setAttribute('data-tag-name', tagName);
            
            // Make images draggable
            if (tagName === 'img') {
                child.setAttribute('draggable', 'true');
                child.style.position = 'relative';
                
                // Add resize handles
                const handles = ['nw', 'ne', 'sw', 'se'];
                handles.forEach(position => {
                    const handle = document.createElement('div');
                    handle.className = `image-resize-handle ${position}`;
                    handle.setAttribute('data-position', position);
                    child.appendChild(handle);
                });
            }
            
            // Make ALL elements (except img) drop zones - you can drop images anywhere!
            if (tagName !== 'img') {
                child.classList.add('drop-zone');
            }
            
            // Recursively process children
            if (child.children.length > 0) {
                makeElementsEditable(child, blockId, currentPath);
            }
        });
    }
    
    function selectTagForEditing(blockId, element) {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        const tagEditor = document.getElementById(`tagEditor_${blockId}`);
        const tagName = document.getElementById(`tagName_${blockId}`);
        const tagContent = document.getElementById(`tagContent_${blockId}`);
        const tagContentGroup = document.getElementById(`tagContentGroup_${blockId}`);
        const tagImageGroup = document.getElementById(`tagImageGroup_${blockId}`);
        const tagImageSrc = document.getElementById(`tagImageSrc_${blockId}`);
        const tagImagePreviewImg = document.getElementById(`tagImagePreviewImg_${blockId}`);
        const tagImagePreviewPlaceholder = document.getElementById(`tagImagePreviewPlaceholder_${blockId}`);
        
        if (!preview || !tagEditor || !tagName || !tagContent) return;
        
        // Remove previous selection
        preview.querySelectorAll('[data-editable-tag].selected').forEach(el => {
            el.classList.remove('selected');
        });
        
        // Mark current element as selected
        element.classList.add('selected');
        
        // Get element path and tag name
        const path = element.getAttribute('data-editable-tag');
        const tag = element.getAttribute('data-tag-name');
        
        // Check if this is an img tag
        const isImgTag = tag.toLowerCase() === 'img';
        
        if (isImgTag) {
            // Show image editor, hide text editor
            if (tagContentGroup) tagContentGroup.style.display = 'none';
            if (tagImageGroup) tagImageGroup.style.display = 'block';
            
            // Get current image src
            const currentSrc = element.getAttribute('src') || '';
            if (tagImageSrc) tagImageSrc.value = currentSrc;
            
            // Update preview
            if (currentSrc && tagImagePreviewImg && tagImagePreviewPlaceholder) {
                tagImagePreviewImg.src = currentSrc;
                tagImagePreviewImg.style.display = 'block';
                tagImagePreviewPlaceholder.style.display = 'none';
            } else if (tagImagePreviewImg && tagImagePreviewPlaceholder) {
                tagImagePreviewImg.style.display = 'none';
                tagImagePreviewPlaceholder.style.display = 'block';
            }
            
            // *** NEW: Extract actual image size from style/attributes and sync with preview size slider ***
            const imgElement = element.querySelector('img') || element;
            const actualImageSize = extractImageSizeFromElement(imgElement);
            
            if (actualImageSize) {
                // Sync the preview image size slider to match the actual image size
                const imageSizeSlider = document.getElementById(`imageSizeSlider_${blockId}`);
                const imageSizeValue = document.getElementById(`imageSizeValue_${blockId}`);
                const imageSizeDisplay = document.getElementById(`imageSizeDisplay_${blockId}`);
                
                if (imageSizeSlider) {
                    imageSizeSlider.value = actualImageSize;
                    updatePreviewImageSize(blockId, actualImageSize);
                }
                
                console.log(`Image clicked: Detected size = ${actualImageSize}px, synced to preview slider`);
            }
        } else {
            // Show text editor, hide image editor
            if (tagContentGroup) tagContentGroup.style.display = 'block';
            if (tagImageGroup) tagImageGroup.style.display = 'none';
            
            // Get direct text content (not including nested elements)
            const textNodes = Array.from(element.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
            const currentText = textNodes.map(node => node.textContent).join('').trim();
            
            tagContent.value = currentText;
        }
        
        // Show tag editor panel
        tagEditor.classList.add('active');
        tagName.textContent = `<${tag}> [${path}]`;
        tagContent.setAttribute('data-editing-path', path);
        
        if (isImgTag && tagImageSrc) {
            tagImageSrc.focus();
        } else {
            tagContent.focus();
        }
        
        // Store current editing element
        tagEditor.setAttribute('data-current-element', path);
    }
    
    // Helper function to extract image size from element's style or attributes
    function extractImageSizeFromElement(imgElement) {
        if (!imgElement) return null;
        
        // Try to get from style attribute (e.g., "max-width: 100px")
        const styleAttr = imgElement.getAttribute('style') || '';
        
        // Try max-width first
        let maxWidthMatch = styleAttr.match(/max-width:\s*(\d+)px/i);
        if (maxWidthMatch) {
            return parseInt(maxWidthMatch[1]);
        }
        
        // Try width
        let widthMatch = styleAttr.match(/width:\s*(\d+)px/i);
        if (widthMatch) {
            return parseInt(widthMatch[1]);
        }
        
        // Try inline style object
        if (imgElement.style.maxWidth && imgElement.style.maxWidth.includes('px')) {
            const size = parseInt(imgElement.style.maxWidth);
            if (!isNaN(size)) return size;
        }
        
        if (imgElement.style.width && imgElement.style.width.includes('px')) {
            const size = parseInt(imgElement.style.width);
            if (!isNaN(size)) return size;
        }
        
        // Try width attribute
        if (imgElement.hasAttribute('width')) {
            const size = parseInt(imgElement.getAttribute('width'));
            if (!isNaN(size)) return size;
        }
        
        return null; // No size found
    }
    
    function closeTagEditor(blockId) {
        const tagEditor = document.getElementById(`tagEditor_${blockId}`);
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        
        if (tagEditor) {
            tagEditor.classList.remove('active');
        }
        
        if (preview) {
            preview.querySelectorAll('[data-editable-tag].selected').forEach(el => {
                el.classList.remove('selected');
            });
        }
    }
    
    function deleteTag(blockId) {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const tagEditor = document.getElementById(`tagEditor_${blockId}`);
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        const htmlTextarea = blockDiv.querySelector('.html-code-editor');
        
        if (!tagEditor || !preview || !htmlTextarea) return;
        
        const path = tagEditor.getAttribute('data-current-element');
        if (!path) return;
        
        // Get the element info for confirmation
        const selectedElement = preview.querySelector(`[data-editable-tag="${path}"]`);
        const tagName = selectedElement ? selectedElement.getAttribute('data-tag-name') : 'element';
        
        // Confirm deletion
        if (!confirm(`Are you sure you want to delete this <${tagName}> element?`)) {
            return;
        }
        
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlTextarea.value;
            
            // Find element by path and remove it
            const pathParts = path.split('-').map(Number);
            
            if (pathParts.length === 1) {
                // Root level element - direct child of tempDiv
                const childIndex = pathParts[0];
                const children = Array.from(tempDiv.children);
                if (childIndex < children.length) {
                    tempDiv.removeChild(children[childIndex]);
                }
            } else {
                // Nested element - find parent and remove child
                let parentElement = tempDiv;
                
                // Navigate to parent element
                for (let i = 0; i < pathParts.length - 1; i++) {
                    const childIndex = pathParts[i];
                    const children = Array.from(parentElement.children);
                    if (childIndex < children.length) {
                        parentElement = children[childIndex];
                    } else {
                        console.warn('Path not found in HTML:', path);
                        showToast('Error: Element not found', 'error');
                        return;
                    }
                }
                
                // Remove the target element from its parent
                const targetIndex = pathParts[pathParts.length - 1];
                const children = Array.from(parentElement.children);
                if (targetIndex < children.length) {
                    parentElement.removeChild(children[targetIndex]);
                } else {
                    console.warn('Target element not found at path:', path);
                    showToast('Error: Element not found', 'error');
                    return;
                }
            }
            
            // Update the textarea with new HTML (element removed)
            htmlTextarea.value = tempDiv.innerHTML;
            
            // Update block data
            const block = contentBlocks.find(b => b.id === blockId);
            if (block) {
                block.data = tempDiv.innerHTML;
            }
            
            // Close tag editor
            closeTagEditor(blockId);
            
            // Refresh preview to show the element is gone
            updateHtmlEditorPreview(blockId);
            
            // Show success message
            showToast(`<${tagName}> element deleted successfully!`, 'success');
        } catch (e) {
            console.error('Error deleting tag:', e);
            showToast('Error deleting element. Please try again.', 'error');
        }
    }
    
    function saveTagContent(blockId) {
        const blockDiv = document.querySelector(`[data-block-id="${blockId}"]`);
        if (!blockDiv) return;
        
        const tagEditor = document.getElementById(`tagEditor_${blockId}`);
        const tagContent = document.getElementById(`tagContent_${blockId}`);
        const tagImageSrc = document.getElementById(`tagImageSrc_${blockId}`);
        const tagContentGroup = document.getElementById(`tagContentGroup_${blockId}`);
        const preview = document.getElementById(`htmlPreview_${blockId}`);
        const htmlTextarea = blockDiv.querySelector('.html-code-editor');
        
        if (!tagEditor || !preview || !htmlTextarea) return;
        
        const path = tagContent.getAttribute('data-editing-path');
        
        // Find the block in contentBlocks
        const block = contentBlocks.find(b => b.id === blockId);
        if (!block) return;
        
        // Determine if we're editing an image or text content
        const isImageEdit = tagContentGroup && tagContentGroup.style.display === 'none';
        
        // Update the preview element visually
        const element = preview.querySelector(`[data-editable-tag="${path}"]`);
        if (element) {
            if (isImageEdit && tagImageSrc) {
                // Update image src
                const newSrc = tagImageSrc.value.trim();
                element.setAttribute('src', newSrc);
            } else {
                // Update text content
                const newContent = tagContent.value;
                const textNodes = Array.from(element.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                if (textNodes.length > 0) {
                    textNodes[0].textContent = newContent;
                } else if (element.children.length === 0) {
                    element.textContent = newContent;
                }
            }
        }
        
        // Now update the HTML source directly by parsing and reconstructing
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlTextarea.value;
            
            // Find element by path and update its content
            const pathParts = path.split('-').map(Number);
            let targetElement = tempDiv;
            
            for (let i = 0; i < pathParts.length; i++) {
                const childIndex = pathParts[i];
                const children = Array.from(targetElement.children);
                if (childIndex < children.length) {
                    targetElement = children[childIndex];
                } else {
                    console.warn('Path not found in HTML:', path);
                    break;
                }
            }
            
            // Update content if element found
            if (targetElement && targetElement !== tempDiv) {
                if (isImageEdit && tagImageSrc) {
                    // Update image src attribute
                    const newSrc = tagImageSrc.value.trim();
                    targetElement.setAttribute('src', newSrc);
                } else {
                    // Update text content
                    const newContent = tagContent.value;
                    const textNodes = Array.from(targetElement.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                    if (textNodes.length > 0) {
                        textNodes[0].textContent = newContent;
                    } else if (targetElement.children.length === 0) {
                        targetElement.textContent = newContent;
                    }
                }
                
                // Update the textarea with new HTML (this is the source of truth)
                htmlTextarea.value = tempDiv.innerHTML;
                
                // Update block data with new HTML directly
                block.data = tempDiv.innerHTML;
            }
        } catch (e) {
            console.error('Error updating HTML:', e);
        }
        
        // Close tag editor
        closeTagEditor(blockId);
        
        // Show success message
        showToast('Content saved directly to HTML!', 'success');
    }

    function editItem(key, label) {
        document.getElementById('nav_name').value = key;
        document.getElementById('nav_label').value = label;
        document.getElementById('nav_key_old').value = key;
        
        // Clear existing blocks and Quill instances
        contentBlocks = [];
        Object.keys(quillInstances).forEach(blockId => {
            delete quillInstances[blockId];
        });
        
        // Load content blocks - try new format first, then legacy format
        if (blocksData[key] && Array.isArray(blocksData[key])) {
            // New format with blocks
            blocksData[key].forEach((block, index) => {
                const blockId = 'block_' + Date.now() + '_' + index + '_' + Math.random().toString(36).substr(2, 9);
                let blockData = block.data;
                
                // Ensure maps data has proper structure
                if (block.type === 'maps') {
                    if (!blockData || typeof blockData !== 'object') {
                        blockData = { latitude: '', longitude: '' };
                    } else {
                        blockData = {
                            latitude: blockData.latitude || '',
                            longitude: blockData.longitude || ''
                        };
                    }
                } else if (block.type === 'html_editor') {
                    // For html_editor, blockData is just the HTML string
                    // Handle legacy format where it might be an object
                    if (blockData && typeof blockData === 'object' && blockData.html) {
                        blockData = blockData.html;  // Extract HTML from legacy format
                    } else if (typeof blockData !== 'string') {
                        blockData = '';
                    }
                }
                
                contentBlocks.push({
                    id: blockId,
                    type: block.type,
                    data: blockData || ''
                });
            });
        } else {
            // Legacy format - convert to blocks
            if (contentData[key]) {
                contentBlocks.push({
                    id: 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    type: 'content',
                    data: contentData[key]
                });
            }
            if (injectedHtmlData[key]) {
                contentBlocks.push({
                    id: 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    type: 'injected_html',
                    data: injectedHtmlData[key]
                });
            }
            if (pluginData[key] && pluginData[key].maps) {
                const mapsPlugin = pluginData[key].maps;
                if (mapsPlugin.latitude && mapsPlugin.longitude) {
                    contentBlocks.push({
                        id: 'block_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'maps',
                        data: {
                            latitude: mapsPlugin.latitude,
                            longitude: mapsPlugin.longitude
                        }
                    });
                }
            }
        }
        
        renderContentBlocks();
        
        // Load background color from plugin structure
        let bgColor = '';
        if (pluginData[key] && pluginData[key].background_color) {
            bgColor = pluginData[key].background_color;
        }
        
        // Set background color fields and show/hide background color form
        if (bgColor) {
            document.getElementById('enableBackgroundColor').checked = true;
            document.getElementById('backgroundColorCard').style.display = 'block';
            document.getElementById('section_background_color_text').value = bgColor;
            // Try to sync color picker if it's a hex color
            const hexMatch = bgColor.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/);
            if (hexMatch) {
                let hexValue = bgColor;
                // Normalize 3-digit hex to 6-digit
                if (hexValue.length === 4) {
                    hexValue = '#' + hexValue[1] + hexValue[1] + 
                              hexValue[2] + hexValue[2] + 
                              hexValue[3] + hexValue[3];
                }
                document.getElementById('section_background_color_picker').value = hexValue;
            }
            updateBackgroundColorPreview();
        } else {
            document.getElementById('enableBackgroundColor').checked = false;
            document.getElementById('backgroundColorCard').style.display = 'none';
            document.getElementById('section_background_color_picker').value = '#ffffff';
            document.getElementById('section_background_color_text').value = '';
            updateBackgroundColorPreview();
        }
        
        // Scroll to form
        document.getElementById('mainForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function clearForm() {
        const mainForm = document.getElementById('mainForm');
        mainForm.reset();
        
        // Restore CSRF token after reset (reset() clears all form fields)
        let csrfInput = mainForm.querySelector('input[name="csrf_token"]');
        if (csrfInput && csrfTokenValue) {
            csrfInput.value = csrfTokenValue;
        } else if (!csrfInput && csrfTokenValue) {
            // Create CSRF token input if it doesn't exist
            csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrf_token';
            csrfInput.value = csrfTokenValue;
            mainForm.insertBefore(csrfInput, mainForm.firstChild);
        }
        
        document.getElementById('nav_key_old').value = '';
        
        // Clear all content blocks
        contentBlocks = [];
        Object.keys(quillInstances).forEach(blockId => {
            delete quillInstances[blockId];
        });
        renderContentBlocks();
        
        // Clear background color fields
        document.getElementById('enableBackgroundColor').checked = false;
        document.getElementById('backgroundColorCard').style.display = 'none';
        document.getElementById('section_background_color_picker').value = '#ffffff';
        document.getElementById('section_background_color_text').value = '';
        updateBackgroundColorPreview();
    }

    function toggleBackgroundColorForm() {
        const checkbox = document.getElementById('enableBackgroundColor');
        const bgColorCard = document.getElementById('backgroundColorCard');
        
        if (checkbox.checked) {
            bgColorCard.style.display = 'block';
        } else {
            bgColorCard.style.display = 'none';
            // Clear background color fields when disabled
            document.getElementById('section_background_color').value = '#ffffff';
            document.getElementById('section_background_color_text').value = '';
            updateBackgroundColorPreview();
        }
    }

    function updateBackgroundColorPreview() {
        const colorPicker = document.getElementById('section_background_color_picker');
        const textInput = document.getElementById('section_background_color_text');
        const previewDiv = document.getElementById('backgroundColorPreview');
        
        let backgroundValue = textInput.value.trim();
        
        // Update preview with any CSS background value
        if (previewDiv) {
            if (backgroundValue) {
                previewDiv.style.background = backgroundValue;
                // Try to determine text color for contrast (only for solid colors)
                const rgb = parseColorToRgb(backgroundValue);
                if (rgb) {
                    const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
                    previewDiv.style.color = brightness > 128 ? '#000000' : '#ffffff';
                } else {
                    // For gradients or complex backgrounds, use default text color
                    previewDiv.style.color = '#000000';
                }
            } else {
                previewDiv.style.background = '#ffffff';
                previewDiv.style.color = '#000000';
            }
        }
        
        // Sync color picker only if it's a simple hex color
        if (colorPicker && backgroundValue) {
            const hexMatch = backgroundValue.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/);
            if (hexMatch) {
                // Normalize 3-digit hex to 6-digit
                if (backgroundValue.length === 4) {
                    backgroundValue = '#' + backgroundValue[1] + backgroundValue[1] + 
                                    backgroundValue[2] + backgroundValue[2] + 
                                    backgroundValue[3] + backgroundValue[3];
                }
                colorPicker.value = backgroundValue;
            }
        }
    }

    function parseColorToRgb(colorValue) {
        if (!colorValue) return null;
        
        // Try hex color
        let hexMatch = colorValue.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/);
        if (hexMatch) {
            return hexToRgb(colorValue);
        }
        
        // Try rgb/rgba
        let rgbMatch = colorValue.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (rgbMatch) {
            return {
                r: parseInt(rgbMatch[1]),
                g: parseInt(rgbMatch[2]),
                b: parseInt(rgbMatch[3])
            };
        }
        
        // Try named colors (basic set)
        const namedColors = {
            'red': {r: 255, g: 0, b: 0},
            'green': {r: 0, g: 128, b: 0},
            'blue': {r: 0, g: 0, b: 255},
            'white': {r: 255, g: 255, b: 255},
            'black': {r: 0, g: 0, b: 0},
            'yellow': {r: 255, g: 255, b: 0},
            'cyan': {r: 0, g: 255, b: 255},
            'magenta': {r: 255, g: 0, b: 255},
            'gray': {r: 128, g: 128, b: 128},
            'grey': {r: 128, g: 128, b: 128}
        };
        if (namedColors[colorValue.toLowerCase()]) {
            return namedColors[colorValue.toLowerCase()];
        }
        
        return null; // Can't parse (gradient, etc.)
    }

    function clearBackgroundColor() {
        document.getElementById('section_background_color_picker').value = '#ffffff';
        document.getElementById('section_background_color_text').value = '';
        updateBackgroundColorPreview();
    }

    function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }


    function addNewSection() {
        clearForm();
        // Scroll to form
        document.getElementById('mainForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
        // Focus on nav_name input
        setTimeout(function() {
            document.getElementById('nav_name').focus();
        }, 300);
    }

    // Quick helper to change selected text color in Quill (for first focused editor)
    function setQuillTextColor(color) {
        // Find the currently focused Quill editor
        let activeQuill = null;
        Object.keys(quillInstances).forEach(blockId => {
            const quill = quillInstances[blockId];
            if (quill && quill.hasFocus()) {
                activeQuill = quill;
            }
        });
        
        // If no focused editor, use the first one
        if (!activeQuill) {
            const contentBlock = contentBlocks.find(b => b.type === 'content');
            if (contentBlock && quillInstances[contentBlock.id]) {
                activeQuill = quillInstances[contentBlock.id];
            }
        }
        
        if (activeQuill) {
            activeQuill.focus();
            activeQuill.format('color', color || false);
        }
    }
    
    // File picker functions
    let currentFileSource = 'db'; // 'db' or 'static'
    
    function showFilePickerModal(source) {
        const modal = document.getElementById('filePickerModal');
        if (!modal) return;
        
        // Set current source
        currentFileSource = source || 'db';
        
        // Update modal title and icon
        const modalTitle = document.getElementById('filePickerModalTitle');
        const modalIcon = document.getElementById('filePickerModalIcon');
        const toggleButtons = document.getElementById('filePickerSourceToggle');
        
        if (currentFileSource === 'static') {
            if (modalTitle) modalTitle.textContent = 'Select File (Static/JSON)';
            if (modalIcon) {
                modalIcon.className = 'fas fa-folder';
                modalIcon.style.color = '#dc3545';
            }
            // Show toggle buttons
            if (toggleButtons) toggleButtons.style.display = 'flex';
            // Set active button
            document.getElementById('toggleStaticFiles')?.classList.add('active');
            document.getElementById('toggleDbFiles')?.classList.remove('active');
        } else {
            if (modalTitle) modalTitle.textContent = 'Select File (Database)';
            if (modalIcon) {
                modalIcon.className = 'fas fa-folder';
                modalIcon.style.color = '';
            }
            // Show toggle buttons
            if (toggleButtons) toggleButtons.style.display = 'flex';
            // Set active button
            document.getElementById('toggleDbFiles')?.classList.add('active');
            document.getElementById('toggleStaticFiles')?.classList.remove('active');
        }
        
        // Show modal
        if (typeof $ !== 'undefined') {
            $(modal).modal('show');
        } else {
            modal.style.display = 'block';
            modal.classList.add('show');
        }
        
        // Load files
        loadFileList(currentFileSource);
    }
    
    function switchFileSource(source) {
        currentFileSource = source;
        loadFileList(source);
        
        // Update button states
        if (source === 'static') {
            document.getElementById('toggleStaticFiles')?.classList.add('active');
            document.getElementById('toggleDbFiles')?.classList.remove('active');
            const modalTitle = document.getElementById('filePickerModalTitle');
            const modalIcon = document.getElementById('filePickerModalIcon');
            if (modalTitle) modalTitle.textContent = 'Select File (Static/JSON)';
            if (modalIcon) {
                modalIcon.style.color = '#dc3545';
            }
        } else {
            document.getElementById('toggleDbFiles')?.classList.add('active');
            document.getElementById('toggleStaticFiles')?.classList.remove('active');
            const modalTitle = document.getElementById('filePickerModalTitle');
            const modalIcon = document.getElementById('filePickerModalIcon');
            if (modalTitle) modalTitle.textContent = 'Select File (Database)';
            if (modalIcon) {
                modalIcon.style.color = '';
            }
        }
    }
    
    function loadFileList(source) {
        const loadingDiv = document.getElementById('filePickerLoading');
        const listDiv = document.getElementById('filePickerList');
        const emptyDiv = document.getElementById('filePickerEmpty');
        const container = document.getElementById('fileListContainer');
        
        // Show loading
        loadingDiv.style.display = 'block';
        listDiv.style.display = 'none';
        emptyDiv.style.display = 'none';
        container.innerHTML = '';
        
        // Determine API endpoint based on source
        const apiUrl = source === 'static' 
            ? '{{ url_for("admin_file_list_static_api") }}'
            : '{{ url_for("admin_file_list_api") }}';
        
        // Fetch files from API
        fetch(apiUrl)
            .then(response => response.json())
            .then(files => {
                loadingDiv.style.display = 'none';
                
                if (!files || files.length === 0) {
                    emptyDiv.style.display = 'block';
                    return;
                }
                
                // Display files
                listDiv.style.display = 'block';
                files.forEach((file, index) => {
                    const fileItem = document.createElement('a');
                    fileItem.href = '#';
                    fileItem.className = 'list-group-item list-group-item-action file-picker-item';
                    fileItem.onclick = function(e) {
                        e.preventDefault();
                        
                        // Check if we're in tag editor image picker mode
                        if (window.tagEditorImagePickerMode && currentImageTagBlockId) {
                            insertImageForTag(file);
                        } else {
                            insertFileLink(file);
                        }
                        
                        // Close modal
                        if (typeof $ !== 'undefined') {
                            $('#filePickerModal').modal('hide');
                        } else {
                            const modal = document.getElementById('filePickerModal');
                            modal.style.display = 'none';
                            modal.classList.remove('show');
                        }
                    };
                    
                    // Format file size
                    let fileSizeText = '-';
                    if (file.file_size) {
                        if (file.file_size < 1024) {
                            fileSizeText = file.file_size + ' B';
                        } else if (file.file_size < 1048576) {
                            fileSizeText = (file.file_size / 1024).toFixed(2) + ' KB';
                        } else {
                            fileSizeText = (file.file_size / 1048576).toFixed(2) + ' MB';
                        }
                    }
                    
                    fileItem.innerHTML = `
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div class="flex-grow-1">
                                <h6 class="mb-1">
                                    <i class="fas fa-file"></i> ${escapeHtml(file.display_name || file.original_filename || file.file)}
                                </h6>
                                <small class="text-muted">
                                    <i class="fas fa-tag"></i> ${escapeHtml(file.original_filename || file.file)}
                                    <span class="ml-2"><i class="fas fa-hdd"></i> ${fileSizeText}</span>
                                </small>
                            </div>
                            <div>
                                <i class="fas fa-chevron-right text-muted"></i>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(fileItem);
                });
            })
            .catch(error => {
                console.error('Error loading files:', error);
                loadingDiv.style.display = 'none';
                emptyDiv.style.display = 'block';
                emptyDiv.innerHTML = `
                    <i class="fas fa-exclamation-triangle fa-3x text-danger mb-3"></i>
                    <p class="text-danger">Error loading files. Please try again.</p>
                `;
            });
    }
    
    function insertFileLink(file) {
        // Find the currently focused Quill editor
        let activeQuill = null;
        Object.keys(quillInstances).forEach(blockId => {
            const quill = quillInstances[blockId];
            if (quill && quill.hasFocus()) {
                activeQuill = quill;
            }
        });
        
        // If no focused editor, use the first one or create a new content block
        if (!activeQuill) {
            // Try to find any content block
            const contentBlock = contentBlocks.find(b => b.type === 'content');
            if (contentBlock && quillInstances[contentBlock.id]) {
                activeQuill = quillInstances[contentBlock.id];
            } else {
                // Create a new content block
                addContentBlock('content');
                setTimeout(() => {
                    const newBlock = contentBlocks[contentBlocks.length - 1];
                    if (quillInstances[newBlock.id]) {
                        activeQuill = quillInstances[newBlock.id];
                        insertFileLinkIntoQuill(activeQuill, file);
                    }
                }, 200);
                return;
            }
        }
        
        if (activeQuill) {
            insertFileLinkIntoQuill(activeQuill, file);
        }
    }
    
    function insertFileLinkIntoQuill(quill, file) {
        const range = quill.getSelection(true);
        if (!range) {
            quill.focus();
            const newRange = quill.getSelection(true);
            if (!newRange) {
                quill.setSelection(quill.getLength());
            }
        }
        
        const currentRange = quill.getSelection(true) || { index: quill.getLength() };
        
        // Get display name or original filename
        const displayName = file.display_name || file.original_filename || file.file;
        const fileUrl = file.url || file.location || '';
        
        if (fileUrl) {
            // Insert as link
            quill.insertText(currentRange.index, displayName, 'link', fileUrl, 'user');
            // Move cursor after the link
            quill.setSelection(currentRange.index + displayName.length);
        } else {
            // Just insert text if no URL
            quill.insertText(currentRange.index, displayName, 'user');
            quill.setSelection(currentRange.index + displayName.length);
        }
        
        quill.focus();
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Initialize Sortable for navigation list
    function initSortableNavList() {
        const navList = document.getElementById('sortableNavList');
        if (!navList) {
            console.log('Sortable nav list not found');
            return;
        }
        
        if (typeof Sortable === 'undefined') {
            console.error('SortableJS library not loaded');
            return;
        }
        
        new Sortable(navList, {
            animation: 150,
            handle: '.drag-handle',
            ghostClass: 'sortable-ghost',
            chosenClass: 'sortable-chosen',
            dragClass: 'sortable-drag',
            onEnd: function(evt) {
                // Get the new order of navigation keys
                const items = navList.querySelectorAll('.sortable-item');
                const newOrder = Array.from(items).map(item => item.getAttribute('data-key'));
                
                console.log('New order:', newOrder);
                
                // Save the new order to the server
                saveNavigationOrder(newOrder);
            }
        });
        
        console.log('Sortable initialized successfully');
    }
    
    // Save navigation order to server
    function saveNavigationOrder(order) {
        // Show loading indicator
        const navList = document.getElementById('sortableNavList');
        if (navList) {
            navList.style.opacity = '0.6';
            navList.style.pointerEvents = 'none';
        }
        
        fetch('{{ url_for("admin_web_control_reorder_nav") }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token() }}'
            },
            body: JSON.stringify({ order: order })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Navigation order saved successfully');
                // Show success feedback
                showToast('Navigation order saved successfully!', 'success');
            } else {
                console.error('Failed to save navigation order:', data.message);
                showToast('Failed to save order: ' + (data.message || 'Unknown error'), 'error');
                // Reload page to restore original order
                setTimeout(() => location.reload(), 2000);
            }
        })
        .catch(error => {
            console.error('Error saving navigation order:', error);
            showToast('Error saving order. Reloading...', 'error');
            // Reload page to restore original order
            setTimeout(() => location.reload(), 2000);
        })
        .finally(() => {
            // Hide loading indicator
            if (navList) {
                navList.style.opacity = '1';
                navList.style.pointerEvents = 'auto';
            }
        });
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type === 'error' ? 'danger' : 'success'} alert-dismissible fade show`;
        alertDiv.style.position = 'fixed';
        alertDiv.style.top = '20px';
        alertDiv.style.right = '20px';
        alertDiv.style.zIndex = '9999';
        alertDiv.style.minWidth = '300px';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
        `;
        document.body.appendChild(alertDiv);
        
        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 3000);
    }

    // Store CSRF token value globally to ensure it's always available
    let csrfTokenValue = '';
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Store CSRF token value when page loads
        const csrfTokenInput = document.querySelector('#mainForm input[name="csrf_token"]');
        if (csrfTokenInput) {
            csrfTokenValue = csrfTokenInput.value;
        }
        
        // Wait for ImageResize module to load and register it globally
        function initImageResize() {
            // Check if ImageResize is available (try different export formats)
            let ImageResizeModule = null;
            
            if (typeof ImageResize !== 'undefined') {
                // Try different export formats
                if (typeof ImageResize === 'function') {
                    ImageResizeModule = ImageResize;
                } else if (ImageResize.default && typeof ImageResize.default === 'function') {
                    ImageResizeModule = ImageResize.default;
                } else if (ImageResize.ImageResize && typeof ImageResize.ImageResize === 'function') {
                    ImageResizeModule = ImageResize.ImageResize;
                } else if (typeof ImageResize === 'object') {
                    ImageResizeModule = ImageResize;
                }
            }
            
            if (!ImageResizeModule) {
                console.log('Waiting for ImageResize module to load...');
                setTimeout(initImageResize, 100);
                return;
            }
            
            // Register ImageResize module with Quill globally
            try {
                if (!Quill.imports['modules/imageResize']) {
                    Quill.register('modules/imageResize', ImageResizeModule, true);
                    console.log('ImageResize module registered successfully');
                }
            } catch (e) {
                console.error('Error registering ImageResize module:', e);
            }
        }
        
        // Start ImageResize initialization
        initImageResize();
        
        // Set up form submit handler
        const mainForm = document.getElementById('mainForm');
        if (mainForm) {
            mainForm.addEventListener('submit', function(e) {
                // Ensure CSRF token is always present before submission
                let csrfInput = mainForm.querySelector('input[name="csrf_token"]');
                if (!csrfInput || !csrfInput.value) {
                    // Create or restore CSRF token if missing
                    if (!csrfInput) {
                        csrfInput = document.createElement('input');
                        csrfInput.type = 'hidden';
                        csrfInput.name = 'csrf_token';
                        mainForm.insertBefore(csrfInput, mainForm.firstChild);
                    }
                    csrfInput.value = csrfTokenValue;
                }
                
                // Collect data from all blocks
                const blocks = [];
                contentBlocks.forEach(block => {
                    if (block.type === 'content') {
                        const quill = quillInstances[block.id];
                        if (quill) {
                            blocks.push({
                                type: 'content',
                                data: quill.root.innerHTML
                            });
                        }
                    } else if (block.type === 'injected_html') {
                        const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                        if (blockDiv) {
                            const textarea = blockDiv.querySelector('textarea');
                            if (textarea) {
                                blocks.push({
                                    type: 'injected_html',
                                    data: textarea.value
                                });
                            }
                        }
                    } else if (block.type === 'maps') {
                        const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                        if (blockDiv) {
                            const latInput = blockDiv.querySelector('.map-latitude-input');
                            const lngInput = blockDiv.querySelector('.map-longitude-input');
                            const lat = parseFloat(latInput?.value);
                            const lng = parseFloat(lngInput?.value);
                            if (!isNaN(lat) && !isNaN(lng)) {
                                blocks.push({
                                    type: 'maps',
                                    data: {
                                        latitude: lat,
                                        longitude: lng
                                    }
                                });
                            }
                        }
                    } else if (block.type === 'html_editor') {
                        const blockDiv = document.querySelector(`[data-block-id="${block.id}"]`);
                        if (blockDiv) {
                            const htmlTextarea = blockDiv.querySelector('.html-code-editor');
                            if (htmlTextarea) {
                                blocks.push({
                                    type: 'html_editor',
                                    data: htmlTextarea.value  // Just save the HTML directly
                                });
                            }
                        }
                    }
                });
                
                // Save blocks data to hidden input
                document.getElementById('contentBlocksData').value = JSON.stringify(blocks);
                
                // Clear background color field if checkbox is unchecked
                const enableBgColorCheckbox = document.getElementById('enableBackgroundColor');
                if (!enableBgColorCheckbox.checked) {
                    document.getElementById('section_background_color_text').value = '';
                }
            });
        }

        // Handle edit button clicks
        document.querySelectorAll('.edit-item-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                editItem(
                    this.getAttribute('data-key'),
                    this.getAttribute('data-label')
                );
            });
        });

        // Handle delete form submissions
        document.querySelectorAll('.delete-form').forEach(function(form) {
            form.addEventListener('submit', function(e) {
                const label = this.getAttribute('data-label');
                if (!confirm('Are you sure you want to delete "' + label + '"?')) {
                    e.preventDefault();
                    return false;
                }
            });
        });

        // Handle background color changes
        const bgColorPicker = document.getElementById('section_background_color_picker');
        const bgColorTextInput = document.getElementById('section_background_color_text');
        
        if (bgColorPicker) {
            bgColorPicker.addEventListener('input', function() {
                // When color picker changes, update text input with hex value
                bgColorTextInput.value = this.value;
                updateBackgroundColorPreview();
            });
        }
        
        if (bgColorTextInput) {
            bgColorTextInput.addEventListener('input', function() {
                // Update preview in real-time as user types
                updateBackgroundColorPreview();
            });
            
            bgColorTextInput.addEventListener('blur', function() {
                // Ensure preview is updated when user leaves the field
                updateBackgroundColorPreview();
            });
        }
        
        // Handle image URL input changes in HTML Tag Editor (using event delegation)
        document.addEventListener('input', function(e) {
            if (e.target && e.target.id && e.target.id.startsWith('tagImageSrc_')) {
                const blockId = e.target.id.replace('tagImageSrc_', '');
                const tagImagePreviewImg = document.getElementById(`tagImagePreviewImg_${blockId}`);
                const tagImagePreviewPlaceholder = document.getElementById(`tagImagePreviewPlaceholder_${blockId}`);
                const imageSrc = e.target.value.trim();
                
                if (imageSrc && tagImagePreviewImg && tagImagePreviewPlaceholder) {
                    tagImagePreviewImg.src = imageSrc;
                    tagImagePreviewImg.style.display = 'block';
                    tagImagePreviewPlaceholder.style.display = 'none';
                    
                    // Handle image load error
                    tagImagePreviewImg.onerror = function() {
                        this.style.display = 'none';
                        if (tagImagePreviewPlaceholder) {
                            tagImagePreviewPlaceholder.style.display = 'block';
                            tagImagePreviewPlaceholder.textContent = 'Invalid image URL';
                            tagImagePreviewPlaceholder.classList.add('text-danger');
                        }
                    };
                    
                    // Handle image load success
                    tagImagePreviewImg.onload = function() {
                        if (tagImagePreviewPlaceholder) {
                            tagImagePreviewPlaceholder.textContent = 'No image selected';
                            tagImagePreviewPlaceholder.classList.remove('text-danger');
                        }
                    };
                } else if (tagImagePreviewImg && tagImagePreviewPlaceholder) {
                    tagImagePreviewImg.style.display = 'none';
                    tagImagePreviewPlaceholder.style.display = 'block';
                    tagImagePreviewPlaceholder.textContent = 'No image selected';
                    tagImagePreviewPlaceholder.classList.remove('text-danger');
                }
            }
        });


        // Load templates
        loadTemplates();
        
        // Initialize drawer state on page load (drawer is open by default)
        const existingSection = document.getElementById('existingItemsSection');
        const editSection = document.getElementById('editSection');
        const rowContainer = existingSection ? existingSection.closest('.row') : null;
        
        if (existingSection && existingSection.classList.contains('drawer-open')) {
            // Drawer is open - CSS calc() handles width automatically
            if (rowContainer) {
                rowContainer.classList.add('drawer-open-adjacent');
            }
            if (editSection) {
                // Remove Bootstrap column classes - CSS calc() handles width
                editSection.classList.remove('col-lg-12', 'col-lg-6');
            }
            
            // Set initial icon states
            const icon = document.getElementById('toggleExistingItemsIcon');
            if (icon) {
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-left');
            }
            
            const drawerToggleIcon = document.getElementById('drawerToggleIcon');
            if (drawerToggleIcon) {
                drawerToggleIcon.classList.add('drawer-open-icon');
            }
        }
        
        // Initialize Sortable for drag and drop navigation reordering
        initSortableNavList();
    });
    
    // Load templates from server
    function loadTemplates() {
        fetch('{{ url_for("admin_web_control_templates") }}')
            .then(response => response.json())
            .then(templates => {
                const templateList = document.getElementById('templateList');
                templateList.innerHTML = '';
                
                if (Object.keys(templates).length === 0) {
                    templateList.innerHTML = '<div class="dropdown-item-text text-muted">No templates available</div>';
                    return;
                }
                
                Object.keys(templates).forEach(key => {
                    const template = templates[key];
                    const item = document.createElement('a');
                    item.className = 'dropdown-item';
                    item.href = '#';
                    item.innerHTML = `
                        <div>
                            <strong>${template.label || template.name}</strong>
                            ${template.description ? '<small class="text-muted d-block">' + template.description + '</small>' : ''}
                        </div>
                    `;
                    item.addEventListener('click', function(e) {
                        e.preventDefault();
                        applyTemplate(template);
                        // Close dropdown using jQuery (Bootstrap 4)
                        if (typeof $ !== 'undefined') {
                            $('.dropdown-menu').removeClass('show');
                            $('.dropdown-toggle').attr('aria-expanded', 'false');
                        }
                    });
                    templateList.appendChild(item);
                });
            })
            .catch(error => {
                console.error('Error loading templates:', error);
                document.getElementById('templateList').innerHTML = '<div class="dropdown-item-text text-danger">Error loading templates</div>';
            });
    }
    
    // Apply template to form
    function applyTemplate(template) {
        if (!template) return;
        
        // Fill nav_name if empty
        const navNameInput = document.getElementById('nav_name');
        if (!navNameInput.value.trim()) {
            navNameInput.value = template.name || '';
        }
        
        // Fill nav_label if empty
        const navLabelInput = document.getElementById('nav_label');
        if (!navLabelInput.value.trim()) {
            navLabelInput.value = template.label || template.name || '';
        }
        
        // Fill content in Quill editor
        if (quill && template.content) {
            quill.clipboard.dangerouslyPasteHTML(0, template.content);
        }
        
        // Handle map if template has map
        if (template.has_map) {
            document.getElementById('enableMapsPlugin').checked = true;
            document.getElementById('mapsPluginCard').style.display = 'block';
            // Don't auto-fill coordinates, let user enter them
        }
        
        // Show success message
        const alertDiv = document.createElement('div');
        alertDiv.className = 'alert alert-success alert-dismissible fade show';
        alertDiv.innerHTML = `
            Template "${template.label || template.name}" loaded successfully!
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
        `;
        const form = document.getElementById('mainForm');
        form.insertBefore(alertDiv, form.firstChild);
        
        // Auto-dismiss after 3 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 3000);
        
        // Scroll to form
        form.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    // Toggle existing items drawer (right sidebar)
    function toggleExistingItemsSection() {
        const existingSection = document.getElementById('existingItemsSection');
        const editSection = document.getElementById('editSection');
        const rowContainer = existingSection ? existingSection.closest('.row') : null;
        const icon = document.getElementById('toggleExistingItemsIcon');
        const drawerToggleIcon = document.getElementById('drawerToggleIcon');

        if (!existingSection) return;

        const isOpen = existingSection.classList.toggle('drawer-open');

        // Adjust edit section width based on drawer state
        if (rowContainer) {
            if (isOpen) {
                // Drawer is open - edit section uses calc(100% - 420px) via CSS
                rowContainer.classList.remove('drawer-closed-adjacent');
                rowContainer.classList.add('drawer-open-adjacent');
                if (editSection) {
                    // Remove Bootstrap column classes - CSS calc() handles width
                    editSection.classList.remove('col-lg-12', 'col-lg-6');
                }
            } else {
                // Drawer is closed - make edit section full width
                rowContainer.classList.remove('drawer-open-adjacent');
                rowContainer.classList.add('drawer-closed-adjacent');
                if (editSection) {
                    editSection.classList.remove('col-lg-6');
                    editSection.classList.add('col-lg-12');
                }
            }
        }

        // Update header icon (inside drawer)
        if (icon) {
            icon.classList.toggle('fa-chevron-right', !isOpen);
            icon.classList.toggle('fa-chevron-left', isOpen);
        }

        // Update floating button icon rotation
        if (drawerToggleIcon) {
            if (isOpen) {
                drawerToggleIcon.classList.add('drawer-open-icon');
            } else {
                drawerToggleIcon.classList.remove('drawer-open-icon');
            }
        }
    }
</script>
{% endblock %}



